[["index.html", "R Bootcamp - How to use R for Data Science About Why R? License", " R Bootcamp - How to use R for Data Science Yigit Aydede 2022-10-13 About This book covers basics to learn R for Data Science. It is designed for MBAN students. We also have a companion R package named RBootcamp, containing the data sets used as well as interactive exercises for each part. Why R? R is both a programming language and software environment for statistical computing, which is free and open-source. With ever increasing availability of large amounts of data, it is critical to have the ability to analyze the data and learn from it for making informed decisions. Familiarity with software such as R allows users to visualize data, run statistical tests, and apply machine learning algorithms. Even if you already know other software, there are still good reasons to learn R: R is free. If your future employer does not already have R installed, you can always download it for free, unlike other proprietary software packages that require expensive licenses. You can always have access to R on your computer. R gives you access to cutting-edge technology. Top researchers develop statistical learning methods in R, and new algorithms are constantly added to the list of packages you can download. R is a useful skill. Employers that value analytics recognize R as useful and important. If for no other reason, learning R is worthwhile to help boost your resume. Here is a very good article about R and Programming that everybody should read: 7 Reasons for policy professionals to get into R programming in 2019 (Jones_2019?). License This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["introduction.html", "Chapter 1 Introduction 1.1 Installation of R, RStudio and R Packages 1.2 RStudio 1.3 Packages 1.4 Working directory 1.5 Hints 1.6 Console or Script? 1.7 R as a calculator 1.8 Data &amp; Object Types 1.9 R-Style Guide", " Chapter 1 Introduction The following sections will serve as an introduction to the R basics that could be used in data analytics. At the beginning, these introductory R subjects may feel like an overwhelming amount of information. The leaning curve will be steeper as practice more. You should try all of the codes from these examples and solve the practice exercises. R is used both for software development and data analysis. We will not use it for software development but apply some concepts in that area. Our main goal will be to analyze data, but we will also perform programming exercises that help illustrate certain algorithmic concepts. 1.1 Installation of R, RStudio and R Packages To get started, you will need to install two pieces of software: R, the actual programming language: Download it from here. – Chose your operating system, and select the most recent version. RStudio, an excellent integrated development environment (IDE) for working with R, an interface used to interact with R: Download it from here. Throughout this book, you will use RStudio instead of R to learn R programming. 1.2 RStudio Source Pane, click on the plus sign in the top left corner. From the drop-down menu, select R Script . As shown in that dropdown menu, you can also open an R Script by pressing Ctrl+Shift+N. You should now see the screen above. The Console Pane is the interface to R. If you opened R directly instead of opening RStudio, you would see just this console. You can type commands directly in the console. The console displays the results of any command you run. For example, type 2+4 in the command line and press enter. You should see the command you typed, the result of the command, and a new command line. To clear the console, you press Ctrl+L or type cat(“\\014”) in the command line. R code can be entered into the command line directly (in Console Pane) or saved to a script (Source Pane). Let’s try some coding. 2 + 3 #write this on the command line and hit Enter ## [1] 5 Now write the same line into the script in Source Pane and run it The Source Pane is a text editor where you can type your code before running it. You can save your code in a text file called a script. Scripts have typically file names with the extension .R. Any text shown in green is a comment in the script. You write a comment by adding a # to an RScript. Anything to the right of a # is considered a comment and is thus ignored by R when running code. Place your cursor anywhere on the first few lines of code and click Run. You can also run code by pressing Ctrl+Enter. The Environment Pane includes an Environment, a History tab, and a Connections tab. The Connections tab makes it easy to connect to any data source on your system. The Environment tab displays any objects that you have created during your R session. For example, if we create three variables: \\(x\\), \\(y\\), and \\(z\\), R stored those variables as objects so that you can see them in the Environment pane. To do object assignments, you need to assign value(s) to a name via the assignment operator, which will create a new object with a name. x &lt;- 5 y &lt;- x*1.5 z &lt;- x - y*3 ls() ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; We will discuss R objects in more detail later. If you want to see a list of all objects in the current session, type ls() in the command line. You can remove an individual object from the environment with the rm() command. For example, remove \\(x\\) by typing rm(x) in the command line. You can remove all objects from the environment by clicking or typing rm(list=ls()) in the command line. The History tab keeps a record of all the commands you have run. To copy a command from the history into the console, select the command and press Enter. The Files Pane includes several tabs that provide useful information. The Files tab displays the contents of your working directory. The Plot tab shows all graphs that you have created. The Packages tab displays the R packages that you have installed in your System Library. 1.3 Packages An R package typically includes code, data, documentation for the package and functions inside, and tests to check everything works as it should. Check to see if the package moments has been installed. If you cannot find it, you need to install it by using the command install.packages(\"moments\"). Once you have installed the package, you need to load it using the command library(moments). Or you can use install tab and follow the instructions and the go to package to check it to activate as shown below. The help tab has built-in documentation for packages and functions in R. The help is automatically available for any loaded packages. You can access that file by typing help(mean) or ?mean in the command line. You can also use the search bar in the help tab. The packages can be installed from sources other than CRAN. For example, in this book we will use RBootcamp which is not located on CRAN #install.packages(&quot;remotes&quot;) #remotes::install_github(&quot;yaydede/RBootcamp&quot;) One of the most difficult things to do when learning R is to know how to find help. Your very first helper should be Google where you post your error message or a short description of your issue. The ability to solve problems using this method is quickly becoming an extremely valuable skill. Do not be discouraged by running into errors and difficulties when learning R. It is simply part of the learning process. The Viewer tab displays HTML output. R packages such as R Markdown and Shiny create HTML outputs that you can view in the Viewer tab. We’ll see it later. 1.4 Working directory Without further specification, files will be loaded from and saved to the working directory. The functions getwd() and setwd() will get and set the working directory, respectively. getwd() ## [1] &quot;/Users/yigitaydede/Dropbox/Documents/Courses/MBAN/RBootcamps/Bootcamp_book&quot; #setwd(&quot;Book2022&quot;) #List all the objects in your local workspace using ls() ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; #List all the files in your working directory using list.files() or dir() ## [1] &quot;_book&quot; &quot;_bookdown_files&quot; ## [3] &quot;_bookdown.yml&quot; &quot;_main_files&quot; ## [5] &quot;_output.yml&quot; &quot;01-intro.Rmd&quot; ## [7] &quot;02-cross-refs_files&quot; &quot;02-Others_files&quot; ## [9] &quot;02-Others.Rmd&quot; &quot;03-ReadWrite.Rmd&quot; ## [11] &quot;04-visual_files&quot; &quot;04-visual.Rmd&quot; ## [13] &quot;05-DataMan_files&quot; &quot;05-DataMan.Rmd&quot; ## [15] &quot;06-Progrmamingbasics.Rmd&quot; &quot;07-Sim_cache&quot; ## [17] &quot;07-Sim_files&quot; &quot;07-Sim.Rmd&quot; ## [19] &quot;08-cross-refs_files&quot; &quot;09-parts.Rmd&quot; ## [21] &quot;10-citations.Rmd&quot; &quot;11-blocks.Rmd&quot; ## [23] &quot;12-share.Rmd&quot; &quot;13-references.Rmd&quot; ## [25] &quot;14-cross-refs_files&quot; &quot;14-cross-refs.Rmd&quot; ## [27] &quot;Book_for_RBootcamp.log&quot; &quot;Book_for_RBootcamp.rds&quot; ## [29] &quot;book.bib&quot; &quot;Bootcamp_book.Rproj&quot; ## [31] &quot;docs&quot; &quot;index.md&quot; ## [33] &quot;index.Rmd&quot; &quot;packages.bib&quot; ## [35] &quot;png&quot; &quot;preamble.tex&quot; ## [37] &quot;README.md&quot; &quot;render820c61d0b188.rds&quot; ## [39] &quot;some_functions.R&quot; &quot;style.css&quot; ## [41] &quot;table1.text&quot; #As we go through this lesson, you should be examining the help page #for each new function. Check out the help page for list.files with the #command ?list.files #or help(&quot;list.files&quot;) #Using the args() function on a function name is also a handy way to #see what arguments a function can take. args(list.files) ## function (path = &quot;.&quot;, pattern = NULL, all.files = FALSE, full.names = FALSE, ## recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, ## no.. = FALSE) ## NULL For this bootcamp, I would suggest to create a RStudio Project in your local driver. RStudio projects make it straightforward to divide your work into multiple contexts, each with their own working directory, workspace, history, and source documents. RStudio projects are associated with R working directories. You can create an RStudio project: In a brand new directory In an existing directory where you already have R code and data By cloning a version control (Git or Subversion) repository To create a new project in the RStudio, use the Create Project command (available on the Projects menu and on the global toolbar) 1.5 Hints R distinguishes upper case from lower case letters. Thus a variable named X differs from another variable named x. The way to learn programming is through practice. The learning curve to R is not bad. You may struggle a bit in the process, but the skills learned will be invaluable for you in the future. There are many ways to write a code to solve the same thing. You can develop your own style. But, if you see nother and better code, try to learn from others! There are many option that you can customize R Studio. Check out Tools &gt; Global Options &gt; General tab in the menu bar of RStudio. Before you start coding, draft a plan to address the question at hand. There is convention in writing codes. Try to adhere these accepted styles. Comment your code properly (using a # sign at the beginning of each line). Good documentation is a great reminder what you have done. Believe me you will forget later the lines in the your own script. The character &gt; in the R Console indicates that R is ready for you to enter a command. Do not overwrite the original data set and variables. Create new data sets just to be sure, especially when taking a subset from that data set. 1.6 Console or Script? The Script Window is the place to enter and run your code so that it is easily edited and saved for future use. You create new R Script by clicking on File &gt; New File &gt; R Script in the RStudio menu bar. To execute your code in the R script, you can either highlight the code and click on Run, or you can highlight the code and press CTRL + Enter on your keyboard. If you prefer, you can enter code directly in the Console Window and click Enter. The commands that you run will be shown in the History Window on the top right of RStudio. You can save these commands for future use. Or, to find the older commands in the console, use the upper arrow to get them again … Make sure you save your code. With your code, you can always regenerate your workspace but it could take a little time. Or you can save your workspace which allows you to start where you left off, with all of the variables you created and renamed saved. Your code (in your script window) is saved by clicking the SAVE button in the RStudio menu bar. The code will be saved in the working directory. See 2.1 for setting and getting the working directory. 1.7 R as a calculator At a very basic level, we can use R as a calculator. See Lesson1 in our package Rbootcamp: library(RBootcamp) #learnr::run_tutorial(&quot;Lesson1&quot;, &quot;RBootcamp&quot;) 1.8 Data &amp; Object Types R has a number of basic data types. Numeric: Also known as Double. The default type when dealing with numbers. 1,1.0,42.5 Integer: 1L,2L,42L Complex: 4 + 2i Logical: Two possible values: TRUE and FALSE. NA is also considered logical. Character:“a”,“Statistics”,“1plus2.” R also has a number of basic data structures. A data structure is either homogeneous (all elements are of the same data type) or heterogeneous (elements can be of more than one data type): You can think each data structure as data container (object types) where you data is stored. Here are the main “container” or data structures. Think it as Stata or Excel spread-sheets. Vector: 1 dimension (column OR row) and homogeneous. That is every element of the vector has to be the same type. Each vector can be thought of as a variable. Matrix: 2 dimensions (column AND row) and homogeneous. That is every element of the matrix has to be the same type. Data Frame: 2 dimensions (column AND row) and heterogeneous. That is every element of the data frame doesn’t have to be the same type. This is the main difference between a matrix and a data frame. Data frames are the most common data structure in any data analysis. List: 1 dimension and heterogeneous. Data can be multiple data structures. Array: 3+ dimensions and homogeneous. 1.9 R-Style Guide The idea is simple: your R code, or any other code in different languages, should be written in a readable and maintainable style. Here is a blog by Roman Pahl that may help you develop a better styling in your codes. (You may find in some chapters and labs that my codes are not following the “good” styling practices. I am trying to improve!) "],["vectors.html", "Chapter 2 Vectors 2.1 One type, same type 2.2 Patterns 2.3 Attributes 2.4 Character operators 2.5 Sort, rank, and order 2.6 Simple descriptive measures 2.7 Subsetting Vectors 2.8 Vectorization or vector operations 2.9 Set operations 2.10 Missing values 2.11 Factors", " Chapter 2 Vectors Many operations in R make heavy use of vectors. Possibly the most common way to create a vector in R is using the c() function, which is short for “combine.” As the name suggests, it combines a list of elements separated by commas. c(1, 5, 0, -1) ## [1] 1 5 0 -1 If we would like to store this vector in a variable we can do so with the assignment operator &lt;- or =. But the convention is &lt;- x &lt;- c(1, 5, 0, -1) z = c(1, 5, 0, -1) x ## [1] 1 5 0 -1 z ## [1] 1 5 0 -1 Note that scalars do not exists in R. They are simply vectors of length 1. y &lt;- 24 #this a vector with 1 element, 24 2.1 One type, same type Because vectors must contain elements that are all the same type, R will automatically coerce to a single type when attempting to create a vector that combines multiple types. c(10, &quot;Machine Learning&quot;, FALSE) ## [1] &quot;10&quot; &quot;Machine Learning&quot; &quot;FALSE&quot; c(10, FALSE) ## [1] 10 0 c(10, TRUE) ## [1] 10 1 x &lt;- c(10, &quot;Machine Learning&quot;, FALSE) str(x) #this tells us the structure of the object ## chr [1:3] &quot;10&quot; &quot;Machine Learning&quot; &quot;FALSE&quot; class(x) ## [1] &quot;character&quot; y &lt;- c(10, FALSE) str(y) ## num [1:2] 10 0 class(y) ## [1] &quot;numeric&quot; We know that vectors are objects that have values of the same type. If you combine them into a vector, R will unify all values into the most complex one, which is usually called the coercion rule. m &lt;- c(TRUE, 5, -2, FALSE) m ## [1] 1 5 -2 0 class(m) ## [1] &quot;numeric&quot; And, m_2 &lt;- c(8, &quot;Joe&quot;, 21, &quot;Mustang&quot;) m_2 ## [1] &quot;8&quot; &quot;Joe&quot; &quot;21&quot; &quot;Mustang&quot; class(m_2) ## [1] &quot;character&quot; You can also manually convert the vectors n &lt;- c(8, 3, 21, 2) n ## [1] 8 3 21 2 nc &lt;- as.character(n) nc ## [1] &quot;8&quot; &quot;3&quot; &quot;21&quot; &quot;2&quot; n &lt;- as.numeric(nc) n ## [1] 8 3 21 2 And be careful: m_2 &lt;- c(8, &quot;Joe&quot;, 21, &quot;Mustang&quot;) as.numeric(m_2) ## Warning: NAs introduced by coercion ## [1] 8 NA 21 NA 2.2 Patterns If you want to create a vector based on a sequence of numbers, you can do it easily with an operator, which creates a sequence of integers between two specified integers. y &lt;- c(1:15) y ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #or y &lt;- 1:15 y ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 If you want to create a vector based on a specific sequence of numbers increasing or decreasing, you can use seq() y &lt;- seq(from = 1.5, to = 13, by = 0.9) #increasing y ## [1] 1.5 2.4 3.3 4.2 5.1 6.0 6.9 7.8 8.7 9.6 10.5 11.4 12.3 y &lt;- seq(1.5, -13, -0.9) #decreasing. Note that you can ignore the argument labels y ## [1] 1.5 0.6 -0.3 -1.2 -2.1 -3.0 -3.9 -4.8 -5.7 -6.6 -7.5 -8.4 ## [13] -9.3 -10.2 -11.1 -12.0 -12.9 The other useful tool is rep() rep(&quot;ML&quot;, times = 10) ## [1] &quot;ML&quot; &quot;ML&quot; &quot;ML&quot; &quot;ML&quot; &quot;ML&quot; &quot;ML&quot; &quot;ML&quot; &quot;ML&quot; &quot;ML&quot; &quot;ML&quot; #or x &lt;- c(1, 5, 0, -1) rep(x, times = 2) ## [1] 1 5 0 -1 1 5 0 -1 And we can use them as follows. wow &lt;- c(x, rep(seq(1, 9, 2), 3), c(1, 2, 3), 42, 2:4) wow ## [1] 1 5 0 -1 1 3 5 7 9 1 3 5 7 9 1 3 5 7 9 1 2 3 42 2 3 ## [26] 4 Another one, which can be used to create equal intervals. g &lt;- seq(6, 60, length = 4) g ## [1] 6 24 42 60 See this unique(wow) ## [1] 1 5 0 -1 3 7 9 2 42 4 2.3 Attributes We can calculate the number of elements in a vector: length(wow) ## [1] 26 There is set of functions starting with is.***(). For example: is.numeric(), which checks whether a vector is of numeric type, is.numeric(g) ## [1] TRUE is.character(g) ## [1] FALSE In addition to storing the values of a vector, you can also create named vectors. x &lt;- c(165, 60, 22) x ## [1] 165 60 22 x_n &lt;- c(height = 125, weight = 56, BMI = 21) x_n ## height weight BMI ## 125 56 21 And, attributes(x_n) ## $names ## [1] &quot;height&quot; &quot;weight&quot; &quot;BMI&quot; 2.4 Character operators animals &lt;- c(&quot;dog&quot;, &quot;cat&quot;, &quot;donkey&quot;) nchar(animals) ## [1] 3 3 6 We can concatenate several strings into a single string. wrong &lt;- c(&quot;we have&quot;, &quot;dogs&quot;, &quot;cats&quot;, &quot;and, donkey&quot;) wrong ## [1] &quot;we have&quot; &quot;dogs&quot; &quot;cats&quot; &quot;and, donkey&quot; right &lt;-paste(&quot;we have &quot;, &quot;dogs, &quot;, &quot;cats, &quot;, &quot;and, donkey&quot;) right ## [1] &quot;we have dogs, cats, and, donkey&quot; You can check paste0() hah &lt;- toupper(right) hah ## [1] &quot;WE HAVE DOGS, CATS, AND, DONKEY&quot; haha &lt;-tolower(hah) haha ## [1] &quot;we have dogs, cats, and, donkey&quot; 2.5 Sort, rank, and order x &lt;- c(2, 3, 2, 0, 4, 7) x ## [1] 2 3 2 0 4 7 By default, the sort() function sorts elements in vector in the increasing order. sort(x) ## [1] 0 2 2 3 4 7 sort(x, decreasing = TRUE) ## [1] 7 4 3 2 2 0 The rank() function gives the corresponding positions in the ascending order. rank(x) ## [1] 2.5 4.0 2.5 1.0 5.0 6.0 You can see that the smallest value of x is 0, which corresponds to the fourth element. Thus, the fourth element has rank 1. As for the order() function, it is confusing and a very different function from sort(). order(x) ## [1] 4 1 3 2 5 6 We can see that the order() function returns indices for the elements in the ascending order. 2.6 Simple descriptive measures Let’s have a numeric vector: h &lt;- c(x, rep(seq(1, 9, 2), 3), c(1, 2, 3), 42, 2:4) h ## [1] 2 3 2 0 4 7 1 3 5 7 9 1 3 5 7 9 1 3 5 7 9 1 2 3 42 ## [26] 2 3 4 summary(h) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.000 2.000 3.000 5.357 7.000 42.000 The set of statistical measures: min(h) ## [1] 0 max(h) ## [1] 42 mean(h) ## [1] 5.357143 median(h) ## [1] 3 sd(h) ## [1] 7.650777 range(h) ## [1] 0 42 sum(h) ## [1] 150 cumsum(h) ## [1] 2 5 7 7 11 18 19 22 27 34 43 44 47 52 59 68 69 72 77 ## [20] 84 93 94 96 99 141 143 146 150 prod(h) ## [1] 0 quantile(h) ## 0% 25% 50% 75% 100% ## 0 2 3 7 42 IQR(h) #interquartile range ## [1] 5 We can also find the index number of maximum and minimum numbers which.max(h) ## [1] 25 which.min(h) ## [1] 4 2.7 Subsetting Vectors One of the most confusing subjects in R is subsetting the data containers. It’s an important part in data management and if it is done in 2 steps, the whole operation becomes quite easy: Identifying the index of the element that satisfies the required condition, Calling the index to subset the vector. But before we start, lets see a simple subsetting. (Note the square brackets) #Suppose we have the following vector myvector &lt;- c(1, 2, 3, 4, 5, 8, 4, 10, 12) #I can call each element with its index number: myvector[c(1,6)] ## [1] 1 8 myvector[4:7] ## [1] 4 5 8 4 myvector[-6] ## [1] 1 2 3 4 5 4 10 12 Okay, let’s see commonly used operators for doing comparisons: x &lt;- 3 x &lt; 2 #less ## [1] FALSE x &lt;= 2 #less or equal to ## [1] FALSE x &gt; 1 #bigger ## [1] TRUE x &gt;= 1 #bigger or equal to ## [1] TRUE x == 3 #equal to ## [1] TRUE #x = 3 #Note that this an assignment operator x != 3 #not equal to ## [1] FALSE #Let&#39;s look at this vector myvector &lt;- c(1, 2, 3, 4, 5, 8, 4, 10, 12) #We want to subset only those less than 5 #Step 1: use a logical operator to identify the elements #meeting the condition. logi &lt;- myvector &lt; 5 logi ## [1] TRUE TRUE TRUE TRUE FALSE FALSE TRUE FALSE FALSE #logi is a logical vector class(logi) ## [1] &quot;logical&quot; #Step 2: use it for subsetting newvector &lt;- myvector[logi==TRUE] newvector ## [1] 1 2 3 4 4 or better: newvector &lt;- myvector[logi] newvector ## [1] 1 2 3 4 4 This is good as it shows those 2 steps. Perhaps, we can combine these 2 steps as follows: newvector &lt;- myvector[myvector &lt; 5] newvector ## [1] 1 2 3 4 4 Another way to do this is to use of which(), which gives us the index of each element that satisfies the condition. ind &lt;- which(myvector &lt; 5) # Step 1 ind ## [1] 1 2 3 4 7 newvector &lt;- myvector[ind] # Step 2 newvector ## [1] 1 2 3 4 4 Or we can combine these 2 steps: newvector &lt;- myvector[which(myvector &lt; 5)] newvector ## [1] 1 2 3 4 4 Last one: find the 4’s in myvector make them 8 (I know hard, but after a couple of tries it will seem easier): myvector &lt;- c(1, 2, 3, 4, 5, 8, 4, 10, 12) #I&#39;ll show you 3 ways to do that. #1st way to show the steps ind &lt;- which(myvector==4) #identifying the index with 4 newvector &lt;- myvector[ind] + 4 # adding them 4 myvector[ind] &lt;- newvector #replacing those with the new values myvector ## [1] 1 2 3 8 5 8 8 10 12 #2nd and easier way myvector[which(myvector==4)] &lt;- myvector[which(myvector==4)] + 4 myvector ## [1] 1 2 3 8 5 8 8 10 12 #3nd and easiest way myvector[myvector==4] &lt;- myvector[myvector==4] + 4 myvector ## [1] 1 2 3 8 5 8 8 10 12 What happens if the vector is a character vector? How can we subset it? We can use grep() as shown below: m &lt;- c(&quot;about&quot;, &quot;aboard&quot;, &quot;board&quot;, &quot;bus&quot;, &quot;cat&quot;, &quot;abandon&quot;) #Now suppose that we need to pick the elements that contain &quot;ab&quot; #Same steps again a &lt;- grep(&quot;ab&quot;, m) #similar to which() that gives us index numbers a ## [1] 1 2 6 newvector &lt;- m[a] newvector ## [1] &quot;about&quot; &quot;aboard&quot; &quot;abandon&quot; 2.8 Vectorization or vector operations One of the biggest strengths of R is its use of vectorized operations. Lets see it in action! x &lt;- 1:10 x ## [1] 1 2 3 4 5 6 7 8 9 10 x+1 ## [1] 2 3 4 5 6 7 8 9 10 11 2 * x ## [1] 2 4 6 8 10 12 14 16 18 20 2 ^ x ## [1] 2 4 8 16 32 64 128 256 512 1024 x ^ 2 ## [1] 1 4 9 16 25 36 49 64 81 100 sqrt(x) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 ## [9] 3.000000 3.162278 log(x) ## [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101 ## [8] 2.0794415 2.1972246 2.3025851 Its like a calculator! y &lt;- 1:10 y ## [1] 1 2 3 4 5 6 7 8 9 10 x + y ## [1] 2 4 6 8 10 12 14 16 18 20 How about this: y &lt;- 1:11 x + y ## Warning in x + y: longer object length is not a multiple of shorter object ## length ## [1] 2 4 6 8 10 12 14 16 18 20 12 OK, the warning is self-explanatory. But what’s “12” at the end? It’s the sum of the first element of x, which is 1 and the last element of y, which is 11. 2.9 Set operations x &lt;- c(1, 2, 1, 3, 1) y &lt;- c(1, 1, 3, 6, 6, 5) You can use the intersect() function to get values in both x and y: intersect(x, y) ## [1] 1 3 To get values in either x or y union(x, y) ## [1] 1 2 3 6 5 To get values in x but not in y setdiff(x, y) ## [1] 2 setdiff(y, x) ## [1] 6 5 To check whether each element of x is inside y is.element(x, y) ## [1] TRUE FALSE TRUE TRUE TRUE # or x %in% y ## [1] TRUE FALSE TRUE TRUE TRUE 2.10 Missing values R uses NA to represent missing values indicating they are not available. In a data file, NA’s are very common and have to be dealt with properly. Why? x &lt;- c(1, NA, 2, NA, 3) mean(x) ## [1] NA sum(x) ## [1] NA And it’s contagious y &lt;- 1:5 x+y ## [1] 2 NA 5 NA 8 To deal with NA’s, we need to know how to find indices with missing values # Do we have and NA? anyNA(x) ## [1] TRUE # Which ones? is.na(x) ## [1] FALSE TRUE FALSE TRUE FALSE # Or which(is.na(x)) ## [1] 2 4 How to remove? But before removing them: mean(x, na.rm = TRUE) ## [1] 2 So we may skip removing them from the data as many functions have built-in arguments to deal with NA’s. x2 &lt;- x[!is.na(x)] x2 ## [1] 1 2 3 # Or x[complete.cases(x)] ## [1] 1 2 3 2.11 Factors Factor type is known as an “indicator” variable. set.seed((123)) anim &lt;- sample(animals, 100, replace = TRUE) anim ## [1] &quot;donkey&quot; &quot;donkey&quot; &quot;donkey&quot; &quot;cat&quot; &quot;donkey&quot; &quot;cat&quot; &quot;cat&quot; &quot;cat&quot; ## [9] &quot;donkey&quot; &quot;dog&quot; &quot;cat&quot; &quot;cat&quot; &quot;dog&quot; &quot;cat&quot; &quot;donkey&quot; &quot;dog&quot; ## [17] &quot;donkey&quot; &quot;donkey&quot; &quot;dog&quot; &quot;dog&quot; &quot;dog&quot; &quot;dog&quot; &quot;donkey&quot; &quot;cat&quot; ## [25] &quot;donkey&quot; &quot;cat&quot; &quot;dog&quot; &quot;cat&quot; &quot;donkey&quot; &quot;cat&quot; &quot;dog&quot; &quot;donkey&quot; ## [33] &quot;donkey&quot; &quot;dog&quot; &quot;donkey&quot; &quot;cat&quot; &quot;dog&quot; &quot;donkey&quot; &quot;dog&quot; &quot;dog&quot; ## [41] &quot;cat&quot; &quot;donkey&quot; &quot;donkey&quot; &quot;dog&quot; &quot;donkey&quot; &quot;dog&quot; &quot;donkey&quot; &quot;cat&quot; ## [49] &quot;dog&quot; &quot;cat&quot; &quot;dog&quot; &quot;dog&quot; &quot;donkey&quot; &quot;dog&quot; &quot;cat&quot; &quot;dog&quot; ## [57] &quot;dog&quot; &quot;donkey&quot; &quot;dog&quot; &quot;cat&quot; &quot;dog&quot; &quot;donkey&quot; &quot;dog&quot; &quot;donkey&quot; ## [65] &quot;cat&quot; &quot;donkey&quot; &quot;cat&quot; &quot;cat&quot; &quot;donkey&quot; &quot;cat&quot; &quot;cat&quot; &quot;donkey&quot; ## [73] &quot;donkey&quot; &quot;dog&quot; &quot;cat&quot; &quot;cat&quot; &quot;dog&quot; &quot;cat&quot; &quot;dog&quot; &quot;dog&quot; ## [81] &quot;cat&quot; &quot;donkey&quot; &quot;donkey&quot; &quot;dog&quot; &quot;cat&quot; &quot;dog&quot; &quot;cat&quot; &quot;dog&quot; ## [89] &quot;donkey&quot; &quot;donkey&quot; &quot;cat&quot; &quot;donkey&quot; &quot;dog&quot; &quot;cat&quot; &quot;cat&quot; &quot;donkey&quot; ## [97] &quot;cat&quot; &quot;dog&quot; &quot;donkey&quot; &quot;donkey&quot; table(anim) ## anim ## cat dog donkey ## 32 33 35 Let’s define anim vector as factor variable: animf &lt;-as.factor(anim) levels(animf) ## [1] &quot;cat&quot; &quot;dog&quot; &quot;donkey&quot; "],["other-r-objects.html", "Chapter 3 Other R Objects 3.1 Matrices 3.2 Data Frames 3.3 Lists 3.4 Array", " Chapter 3 Other R Objects This chapter introduces other types of R objects: matrix, data frame, list, and array. 3.1 Matrices R stores matrices (and arrays) in a similar way as vectors, but with the attribute called dimension. A matrix is an array that has two dimensions. Data in a matrix are organized into rows and columns. Matrices are commonly used while arrays are rare. We will not see arrays in this book in detail. Matrices are homogeneous data structures, just like atomic vectors, but they can have 2 dimensions, rows and columns, unlike vectors. Matrices can be created using the matrix function. In the matrix() function, after the data vector, nrow and ncol specify the desired numbers of rows and columns of the matrix. #Let&#39;s create 5 x 4 numeric matrix containing numbers from 1 to 20 mymatrix &lt;- matrix(1:20, nrow = 5, ncol = 4) #Here we order the number by columns mymatrix ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 7 12 17 ## [3,] 3 8 13 18 ## [4,] 4 9 14 19 ## [5,] 5 10 15 20 class(mymatrix) ## [1] &quot;matrix&quot; &quot;array&quot; dim(mymatrix) ## [1] 5 4 Notice that the matrix is created by filling in the columns. If you want to fill the rows instead of columns, you can add the argument byrow = TRUE. mymatrix &lt;- matrix(1:20, nrow = 5, ncol = 4, byrow = TRUE) mymatrix ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 ## [4,] 13 14 15 16 ## [5,] 17 18 19 20 We will be using two different variables. Following the usual mathematical convention, lower-case x (or any other letter), which stores a vector and capital X, which stores a matrix. Don’t forget: we can do this because R is case sensitive. If the length of the supplied vector is not equal to the number of rows multiplied by the number of columns, R will use the recycling rule on the vector to fill in the matrix, which is usefull: matrix(6, 3, 3) ## [,1] [,2] [,3] ## [1,] 6 6 6 ## [2,] 6 6 6 ## [3,] 6 6 6 After defining a matrix, we can apply various functions on it. x &lt;- matrix(1:12, nrow = 4) dim(x) #the dimension of a matrix ## [1] 4 3 nrow(x) #the number of row of a matrix ## [1] 4 ncol(x) #the number of column of a matrix ## [1] 3 3.1.1 Matrix Operations Now some key matrix operations: X &lt;- matrix(1:9, nrow = 3, ncol = 3) Y &lt;- matrix(11:19, nrow = 3, ncol = 3) A &lt;- X + Y A ## [,1] [,2] [,3] ## [1,] 12 18 24 ## [2,] 14 20 26 ## [3,] 16 22 28 B &lt;- X * Y B ## [,1] [,2] [,3] ## [1,] 11 56 119 ## [2,] 24 75 144 ## [3,] 39 96 171 #The symbol %*% is called pipe operator. #And it carries out a matrix multiplication #different than a simple multiplication. C &lt;- X%*%Y C ## [,1] [,2] [,3] ## [1,] 150 186 222 ## [2,] 186 231 276 ## [3,] 222 276 330 Note that X * Y is not a matrix multiplication. It is element by element multiplication. (Same for X / Y). Instead, matrix multiplication uses %*%. Other matrix functions include t() which gives the transpose of a matrix and solve() which returns the inverse of a square matrix if it is invertible. Here are some operations very useful when using matrices: rowMeans(A) ## [1] 18 20 22 colMeans(B) ## [1] 24.66667 75.66667 144.66667 rowSums(B) ## [1] 186 243 306 colSums(A) ## [1] 42 60 78 Last thing: When vectors are coerced to become matrices, they are column vectors. So a vector of length n becomes an \\(n \\times 1\\) matrix after coercion. x &lt;- 1:5 X &lt;- as.matrix(x) X ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 ## [5,] 5 3.1.2 Combine vectors or matrices into a matrix The matrix() function is not the only way to create a matrix. Matrices can also be created by combining vectors as columns, using cbind(), or combining vectors as rows, using rbind(). Look at this: #Let&#39;s create 2 vectors. x &lt;- rev(c(1:9)) #this can be done by c(9:1). I wanted to show rev() x ## [1] 9 8 7 6 5 4 3 2 1 y &lt;- rep(2, 9) y ## [1] 2 2 2 2 2 2 2 2 2 A &lt;- rbind(x, y) A ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ## x 9 8 7 6 5 4 3 2 1 ## y 2 2 2 2 2 2 2 2 2 B &lt;- cbind(x, y) B ## x y ## [1,] 9 2 ## [2,] 8 2 ## [3,] 7 2 ## [4,] 6 2 ## [5,] 5 2 ## [6,] 4 2 ## [7,] 3 2 ## [8,] 2 2 ## [9,] 1 2 #You can label each column and row colnames(B) &lt;- c(&quot;column1&quot;, &quot;column2&quot;) B ## column1 column2 ## [1,] 9 2 ## [2,] 8 2 ## [3,] 7 2 ## [4,] 6 2 ## [5,] 5 2 ## [6,] 4 2 ## [7,] 3 2 ## [8,] 2 2 ## [9,] 1 2 Also we can append or merge several matrices m1 &lt;- matrix(1:6, 2, 3) m1 ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 m2 &lt;- matrix(5:10, 2, 3) m2 ## [,1] [,2] [,3] ## [1,] 5 7 9 ## [2,] 6 8 10 rbind(m1, m2) # Append ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## [3,] 5 7 9 ## [4,] 6 8 10 cbind(m1, m2) # Merge ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 3 5 5 7 9 ## [2,] 2 4 6 6 8 10 3.1.3 Subsetting Matrix Like vectors, matrices can be subsetted using square brackets, [ ]. However, since matrices are two-dimensional, we need to specify both row and column indices when subsetting. Y ## [,1] [,2] [,3] ## [1,] 11 14 17 ## [2,] 12 15 18 ## [3,] 13 16 19 Y[1,3] ## [1] 17 Y[,3] ## [1] 17 18 19 Y[2,] ## [1] 12 15 18 Y[2, c(1, 3)] # If we need more than a column (row), we use c() ## [1] 12 18 rownames(Y) &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) colnames(Y) &lt;- c(&quot;x&quot;,&quot;y&quot;,&quot;z&quot;) Yn &lt;- Y[, c(1, 3)] Yn ## x z ## a 11 17 ## b 12 18 ## c 13 19 If you need to keep the result as a matrix, you can add a third dimension drop = FALSE in the subsetting operation. Conditional subsetting is the same as before in vectors. Let’s solve this problem: what’s the number in column 1 in Y when the number in column 3 is 18? Y ## x y z ## a 11 14 17 ## b 12 15 18 ## c 13 16 19 Y[Y[,3]==18, 1] ## [1] 12 #What are the numbers in a row when the number in column 3 is 18? Y[Y[,3]==19, ] ## x y z ## 13 16 19 #Print the rows in Y when the number in column 3 is more than 17? Y[Y[,3] &gt; 17, ] ## x y z ## b 12 15 18 ## c 13 16 19 We will see later how these conditional subsetting can be done much smoother with data frames. 3.1.4 apply() function We will see the apply family later in more detail. The apply() function is very handy for matrices if we may want to apply certain function on each row or column. It takes three arguments by default. The first argument is the object, the second argument is the dimension(s) to apply the function on, and the third argument is the function. apply(Y, 2, mean) ## x y z ## 12 15 18 apply(Y, 1, mean) ## a b c ## 14 15 16 apply(Y, 2, sum) ## x y z ## 36 45 54 apply(Y, 2, sd) ## x y z ## 1 1 1 apply(Y, 2, function(g) g^2) ## x y z ## a 121 196 289 ## b 144 225 324 ## c 169 256 361 3.2 Data Frames We have seen vectors and matrices for storing data. We will now introduce a data frame that is the most common way to store and interact with data. Data sets for statistical analysis are typically stored in data frames in R. Unlike a matrix, a data frame can have different data types for each elements (columns). A data frame is a list of vectors (columns - you can think of them as “variables”). So, each vector (column) must contain the same data type, but the different vectors (columns) can store different data types. However, unlike a list, the columns (elements) of a data frame must all be vectors and have the same length (number of observations) Data frames combine the features of matrices and lists. Like matrices, data frames are rectangular, where the columns are variables and the rows are observations of those variables. like lists, data frames can have elements (column vectors) of different data types (some double, some character, etc.) – but they must be equal length. Real data sets usually combine variables of different types, so data frames are well suited for storage. #One way to do that mydata &lt;- data.frame(diabetic = c(TRUE, FALSE, TRUE, FALSE), height = c(65, 69, 71, 73)) mydata ## diabetic height ## 1 TRUE 65 ## 2 FALSE 69 ## 3 TRUE 71 ## 4 FALSE 73 str(mydata) ## &#39;data.frame&#39;: 4 obs. of 2 variables: ## $ diabetic: logi TRUE FALSE TRUE FALSE ## $ height : num 65 69 71 73 dim(mydata) ## [1] 4 2 #Or create vectors for each column diabetic = c(TRUE, FALSE, TRUE, FALSE) height = c(65, 69, 71, 73) #And include them in a data frame as follows mydata &lt;- data.frame(diabetic, height) mydata ## diabetic height ## 1 TRUE 65 ## 2 FALSE 69 ## 3 TRUE 71 ## 4 FALSE 73 str(mydata) ## &#39;data.frame&#39;: 4 obs. of 2 variables: ## $ diabetic: logi TRUE FALSE TRUE FALSE ## $ height : num 65 69 71 73 dim(mydata) ## [1] 4 2 #And more importantly, you can extend it by adding more columns weight = c(103, 45, 98.4, 70.5) mydata &lt;- data.frame(mydata, weight) mydata ## diabetic height weight ## 1 TRUE 65 103.0 ## 2 FALSE 69 45.0 ## 3 TRUE 71 98.4 ## 4 FALSE 73 70.5 You will have the following mistake a lot. Let’s see it now so you can avoid it later. #Try running the code below separately without the comment # and see what happens #mydata &lt;- data.frame(diabetic = c(TRUE, FALSE, TRUE, FALSE, FALSE), #height = c(65, 69, 71, 73)) The problem in the example above is that there are a different number of rows and columns. Here are some useful tools for diagnosing this problem: #Number of columns ncol(mydata) ## [1] 3 nrow(mydata) ## [1] 4 Often data you’re working with has abstract column names, such as (x1, x2, x3…).The cars is data from the 1920s on “Speed and Stopping Distances of Cars”. There is only 2 columns shown below. colnames(datasets::cars) ## [1] &quot;speed&quot; &quot;dist&quot; #Using Base r: colnames(cars)[1:2] &lt;- c(&quot;Speed (mph)&quot;, &quot;Stopping Distance (ft)&quot;) colnames(cars) ## [1] &quot;Speed (mph)&quot; &quot;Stopping Distance (ft)&quot; #Using GREP: colnames(cars)[grep(&quot;dist&quot;, colnames(cars))] &lt;- &quot;Stopping Distance (ft)&quot; colnames(cars) ## [1] &quot;Speed (mph)&quot; &quot;Stopping Distance (ft)&quot; Using summary() on a data frame, you get the summary statistics for each variable. summary(cars) ## Speed (mph) Stopping Distance (ft) ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 3.2.1 Subsetting Data Frames Subsetting data frames can work much like subsetting matrices using square brackets, [,]. Let’s use another data given in the ggplot2 library. library(ggplot2) head(mpg, n = 10) ## # A tibble: 10 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 quattro 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 quattro 2 2008 4 manu… 4 20 28 p comp… And we need to see the cars with highway mpg over 35: mpg[mpg$hwy &gt; 35, c(&quot;manufacturer&quot;, &quot;model&quot;, &quot;year&quot;)] ## # A tibble: 6 × 3 ## manufacturer model year ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 honda civic 2008 ## 2 honda civic 2008 ## 3 toyota corolla 2008 ## 4 volkswagen jetta 1999 ## 5 volkswagen new beetle 1999 ## 6 volkswagen new beetle 1999 An alternative would be to use the subset() function, which has a much more readable syntax. subset(mpg, subset = hwy &gt; 35, select = c(&quot;manufacturer&quot;, &quot;model&quot;, &quot;year&quot;)) ## # A tibble: 6 × 3 ## manufacturer model year ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 honda civic 2008 ## 2 honda civic 2008 ## 3 toyota corolla 2008 ## 4 volkswagen jetta 1999 ## 5 volkswagen new beetle 1999 ## 6 volkswagen new beetle 1999 Lastly, we could use the filter and select functions from the dplyr package which introduces the %&gt;% operator from the magrittr package. This is not necessary for this book, however the dplyr package is something you should be aware of as it is becoming a popular tool in the R world. library(dplyr) mpg %&gt;% filter(hwy &gt; 35) %&gt;% select(manufacturer, model, year) ## # A tibble: 6 × 3 ## manufacturer model year ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 honda civic 2008 ## 2 honda civic 2008 ## 3 toyota corolla 2008 ## 4 volkswagen jetta 1999 ## 5 volkswagen new beetle 1999 ## 6 volkswagen new beetle 1999 We will see dplyr later. 3.2.2 Tibble Tibbles are data frames, but change some behaviors of data frames to make coding easier. To use the tibble class, you need to install the tibble package, which is part of the tidyverse package. library(tibble) animal &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;), c(3,3)) year &lt;- rep(2019:2021, 2) healthy &lt;- c(rep(TRUE, 5), FALSE) my_tibble &lt;- tibble(animal, year, healthy) my_tibble ## # A tibble: 6 × 3 ## animal year healthy ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 sheep 2019 TRUE ## 2 sheep 2020 TRUE ## 3 sheep 2021 TRUE ## 4 pig 2019 TRUE ## 5 pig 2020 TRUE ## 6 pig 2021 FALSE You can convert a tibble to a data frame or data frame to tibble. my_data_frame &lt;- data.frame(animal, year, healthy) tt &lt;- as_tibble(my_data_frame) tt ## # A tibble: 6 × 3 ## animal year healthy ## &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 sheep 2019 TRUE ## 2 sheep 2020 TRUE ## 3 sheep 2021 TRUE ## 4 pig 2019 TRUE ## 5 pig 2020 TRUE ## 6 pig 2021 FALSE # Or bck &lt;- as.data.frame(tt) bck ## animal year healthy ## 1 sheep 2019 TRUE ## 2 sheep 2020 TRUE ## 3 sheep 2021 TRUE ## 4 pig 2019 TRUE ## 5 pig 2020 TRUE ## 6 pig 2021 FALSE In some aspects tibbles are useful, data frames are more common. 3.2.3 Plotting from data frame There are many good ways and packages for plotting. I’ll show you one here. Visualizing the relationship between multiple variables can get messy very quickly. Here is the ggpairs() function in the GGally package (Tay_2019?). library(fueleconomy) #install.packages(&quot;fueleconomy&quot;) data(vehicles) df &lt;- vehicles[1:100, ] str(df) ## tibble [100 × 12] (S3: tbl_df/tbl/data.frame) ## $ id : num [1:100] 13309 13310 13311 14038 14039 ... ## $ make : chr [1:100] &quot;Acura&quot; &quot;Acura&quot; &quot;Acura&quot; &quot;Acura&quot; ... ## $ model: chr [1:100] &quot;2.2CL/3.0CL&quot; &quot;2.2CL/3.0CL&quot; &quot;2.2CL/3.0CL&quot; &quot;2.3CL/3.0CL&quot; ... ## $ year : num [1:100] 1997 1997 1997 1998 1998 ... ## $ class: chr [1:100] &quot;Subcompact Cars&quot; &quot;Subcompact Cars&quot; &quot;Subcompact Cars&quot; &quot;Subcompact Cars&quot; ... ## $ trans: chr [1:100] &quot;Automatic 4-spd&quot; &quot;Manual 5-spd&quot; &quot;Automatic 4-spd&quot; &quot;Automatic 4-spd&quot; ... ## $ drive: chr [1:100] &quot;Front-Wheel Drive&quot; &quot;Front-Wheel Drive&quot; &quot;Front-Wheel Drive&quot; &quot;Front-Wheel Drive&quot; ... ## $ cyl : num [1:100] 4 4 6 4 4 6 4 4 6 5 ... ## $ displ: num [1:100] 2.2 2.2 3 2.3 2.3 3 2.3 2.3 3 2.5 ... ## $ fuel : chr [1:100] &quot;Regular&quot; &quot;Regular&quot; &quot;Regular&quot; &quot;Regular&quot; ... ## $ hwy : num [1:100] 26 28 26 27 29 26 27 29 26 23 ... ## $ cty : num [1:100] 20 22 18 19 21 17 20 21 17 18 ... Let’s see how GGally::ggpairs() visualizes relationships between quantitative variables: library(GGally) #install.packages(&quot;GGally&quot;) new_df &lt;- df[, c(&quot;cyl&quot;, &quot;hwy&quot;, &quot;cty&quot;)] ggpairs(new_df) The visualization changes a little when we have a mix of quantitative and categorical variables. Below, fuel is a categorical variable while hwy is a quantitative variable. mixed_df &lt;- df[, c(&quot;fuel&quot;, &quot;hwy&quot;)] ggpairs(mixed_df) 3.3 Lists A list is a one-dimensional heterogeneous data structure. So it is indexed like a vector with a single integer value, but each element can contain an element of any type. Lets look at some examples of working with them: # creation A &lt;- list(42, &quot;Hello&quot;, TRUE) dim(A) ## NULL str(A) ## List of 3 ## $ : num 42 ## $ : chr &quot;Hello&quot; ## $ : logi TRUE class(A) ## [1] &quot;list&quot; # Another one B &lt;- list( a = c(1, 2, 3, 4), b = TRUE, c = &quot;Hello!&quot;, d = function(arg = 1) {print(&quot;Hello World!&quot;)}, X = matrix(0, 4 , 4) ) B ## $a ## [1] 1 2 3 4 ## ## $b ## [1] TRUE ## ## $c ## [1] &quot;Hello!&quot; ## ## $d ## function(arg = 1) {print(&quot;Hello World!&quot;)} ## ## $X ## [,1] [,2] [,3] [,4] ## [1,] 0 0 0 0 ## [2,] 0 0 0 0 ## [3,] 0 0 0 0 ## [4,] 0 0 0 0 dim(B) ## NULL dim(B$X) ## [1] 4 4 str(B) ## List of 5 ## $ a: num [1:4] 1 2 3 4 ## $ b: logi TRUE ## $ c: chr &quot;Hello!&quot; ## $ d:function (arg = 1) ## ..- attr(*, &quot;srcref&quot;)= &#39;srcref&#39; int [1:8] 12 15 12 55 15 55 12 12 ## .. ..- attr(*, &quot;srcfile&quot;)=Classes &#39;srcfilecopy&#39;, &#39;srcfile&#39; &lt;environment: 0x7fd9ff4b71e0&gt; ## $ X: num [1:4, 1:4] 0 0 0 0 0 0 0 0 0 0 ... class(B) ## [1] &quot;list&quot; Lists can be subset using two types of syntax, the $ operator, and square brackets [ ]. The $ operator returns a named element of a list. The [ ] syntax returns a list, while the [[ ]] returns an element of a list. #For example to get the matrix in our list B$X ## [,1] [,2] [,3] [,4] ## [1,] 0 0 0 0 ## [2,] 0 0 0 0 ## [3,] 0 0 0 0 ## [4,] 0 0 0 0 #or B[5] ## $X ## [,1] [,2] [,3] [,4] ## [1,] 0 0 0 0 ## [2,] 0 0 0 0 ## [3,] 0 0 0 0 ## [4,] 0 0 0 0 #or B[[5]] ## [,1] [,2] [,3] [,4] ## [1,] 0 0 0 0 ## [2,] 0 0 0 0 ## [3,] 0 0 0 0 ## [4,] 0 0 0 0 #And to get the (1,3) element of matrix X in list B B[[5]][1,3] ## [1] 0 What’s the difference between the results of B[[5]] and B[5]? The former is the third element of my_list which is a matrix, while the latter is a list containing a single matrix element. Let’s confirm this by looking at their structures. str(B[[5]]) ## num [1:4, 1:4] 0 0 0 0 0 0 0 0 0 0 ... str(B[5]) ## List of 1 ## $ X: num [1:4, 1:4] 0 0 0 0 0 0 0 0 0 0 ... 3.4 Array Array can be viewed as an extension of vector and matrix to a higher dimensional space, and still only contains elements of the same type. A &lt;- array(1:24, c(2,3,4)) A ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 13 15 17 ## [2,] 14 16 18 ## ## , , 4 ## ## [,1] [,2] [,3] ## [1,] 19 21 23 ## [2,] 20 22 24 dim(A) ## [1] 2 3 4 The first argument is the data input (1:241). The second argument is the dimension of the array: 2 is the number of rows, 3 is the number of columns, and 4 is how many matrices we will have. Here is an example with a higher dimension: y &lt;- array(0, c(2,3,4,5)) y ## , , 1, 1 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 2, 1 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 3, 1 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 4, 1 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 1, 2 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 2, 2 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 3, 2 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 4, 2 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 1, 3 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 2, 3 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 3, 3 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 4, 3 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 1, 4 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 2, 4 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 3, 4 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 4, 4 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 1, 5 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 2, 5 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 3, 5 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## ## , , 4, 5 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 dim(y) ## [1] 2 3 4 5 A[1, 2, 3] #the 3rd matrix with [1,2] ## [1] 15 A[, , 2] #the 2nd matrix ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 A[2, , 4] #the 4th matrix, 2nd row ## [1] 20 22 24 A[-2, 3, -3] #Expect the 3rd matrix, get the 3rd columns without the 2nd rows ## [1] 5 11 23 apply(A, 1, mean) #calculate the mean all rows (we have 2 rows) ## [1] 12 13 # Verify them mean(A[1, , ]) #mean of all 1st rows ## [1] 12 mean(A[2, , ]) #mean of all 2nd rows ## [1] 13 apply(A, 2, sum) #calculate the sum of all columns ## [1] 84 100 116 apply(A, 3, sd) #calculate the sd each matrix ## [1] 1.870829 1.870829 1.870829 1.870829 "],["reading-and-writting-data-files.html", "Chapter 4 Reading and writting data files 4.1 Reading (importing) 4.2 Writing (exporting)", " Chapter 4 Reading and writting data files 4.1 Reading (importing) For any data analysis, we need data. Data come in all different formats. The data could be readable, sometimes called ascii format. Or the data could be unreadable without the original program, like an Excel workbook (.xlsx) or other statistical software formats like Stata (.dta) or SAS (.sas7bdat). There are many ways of bringing data into your workspace. A more flexible way to import data is to use Import Dataset on the Environment tab in the upper right window of RStudio . Multiple file type options are shown, such as text, Excel, SPSS, SAS, and Stata. When you read a data in other formats, they may also be imported as a data frame. If the data is a .csv file, for example, we would also use the read_csv() function from the readr package. Note that R has a built in function read.csv() that operates very similarly. The readr function read_csv() has a number of advantages. For example, it is much faster reading larger data. It also uses the tibble package to read the data as a tibble. library(readr) library(RCurl) x &lt;- getURL(&quot;https://raw.githubusercontent.com/tidyverse/readr/main/inst/extdata/mtcars.csv&quot;) example_csv = read_csv(x, show_col_types = FALSE) head(example_csv) ## # A tibble: 6 × 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 str(example_csv) ## spec_tbl_df [32 × 11] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num [1:32] 160 160 108 258 360 ... ## $ hp : num [1:32] 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num [1:32] 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num [1:32] 16.5 17 18.6 19.4 17 ... ## $ vs : num [1:32] 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num [1:32] 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ... ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. mpg = col_double(), ## .. cyl = col_double(), ## .. disp = col_double(), ## .. hp = col_double(), ## .. drat = col_double(), ## .. wt = col_double(), ## .. qsec = col_double(), ## .. vs = col_double(), ## .. am = col_double(), ## .. gear = col_double(), ## .. carb = col_double() ## .. ) ## - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; A tibble is simply a data frame that prints with sanity. Notice in the output above that we are given additional information such as dimension and variable type. To understand more about the data set, we use the ? operator to pull up the documentation for the data. (You can use ?? to search the Internet for more info) ?mtcars ??mtcars #View(mpg) head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 tail(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 After importing our data, a quick glance at the dataset can often tell us if the data were read in correctly. Use head() and tail() to look at a specified number of rows at the beginning or end of a dataset, respectively. Use View() on a dataset to open a spreadsheet-style view of a dataset. In RStuido, clicking on a dataset in the Environment pane will View() it. 4.2 Writing (exporting) We can export our data in a number of formats, including text, Excel .xlsx, and in other statistical software formats like Stata .dta, using write_functions that reverse the operations of the read_functions. Multiple objects can be stored in an R binary file (usally extension “.Rdata”) with save() and then later loaded with load(). I did not specify realistic path names below. Excel .csv file: write_csv(dat_csv, file = \"path/to/save/filename.csv\") Stata .dta file: write_dta(dat_csv, file = \"path/to/save/filename.dta\") save these objects to an .Rdata file: save(dat_csv, mydata, file=\"path/to/save/filename.Rdata\") One last thing: if you want to save the entire workspace, save.image() is just a short-cut for “save my current workspace”, i.e., save(list = ls(all.names = TRUE), file = \".RData\", envir = .GlobalEnv). It is also what happens with q(\"yes\"). "],["data-visualisation-with-r.html", "Chapter 5 Data visualisation with R 5.1 Scatterplots 5.2 Smootlines 5.3 Histograms &amp; Density 5.4 Multiple plots 5.5 Add lines 5.6 Pairwise relationship", " Chapter 5 Data visualisation with R Let’s first introduce the data set that will be used throughout this chapter. The data set is a part of the Ames Housing Price data, containing 165 observations and 12 features including the sale date and price. library(AmesHousing) amesdata &lt;- make_ames() str(amesdata) ## tibble [2,930 × 81] (S3: tbl_df/tbl/data.frame) ## $ MS_SubClass : Factor w/ 16 levels &quot;One_Story_1946_and_Newer_All_Styles&quot;,..: 1 1 1 1 6 6 12 12 12 6 ... ## $ MS_Zoning : Factor w/ 7 levels &quot;Floating_Village_Residential&quot;,..: 3 2 3 3 3 3 3 3 3 3 ... ## $ Lot_Frontage : num [1:2930] 141 80 81 93 74 78 41 43 39 60 ... ## $ Lot_Area : int [1:2930] 31770 11622 14267 11160 13830 9978 4920 5005 5389 7500 ... ## $ Street : Factor w/ 2 levels &quot;Grvl&quot;,&quot;Pave&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ Alley : Factor w/ 3 levels &quot;Gravel&quot;,&quot;No_Alley_Access&quot;,..: 2 2 2 2 2 2 2 2 2 2 ... ## $ Lot_Shape : Factor w/ 4 levels &quot;Regular&quot;,&quot;Slightly_Irregular&quot;,..: 2 1 2 1 2 2 1 2 2 1 ... ## $ Land_Contour : Factor w/ 4 levels &quot;Bnk&quot;,&quot;HLS&quot;,&quot;Low&quot;,..: 4 4 4 4 4 4 4 2 4 4 ... ## $ Utilities : Factor w/ 3 levels &quot;AllPub&quot;,&quot;NoSeWa&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ Lot_Config : Factor w/ 5 levels &quot;Corner&quot;,&quot;CulDSac&quot;,..: 1 5 1 1 5 5 5 5 5 5 ... ## $ Land_Slope : Factor w/ 3 levels &quot;Gtl&quot;,&quot;Mod&quot;,&quot;Sev&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ Neighborhood : Factor w/ 29 levels &quot;North_Ames&quot;,&quot;College_Creek&quot;,..: 1 1 1 1 7 7 17 17 17 7 ... ## $ Condition_1 : Factor w/ 9 levels &quot;Artery&quot;,&quot;Feedr&quot;,..: 3 2 3 3 3 3 3 3 3 3 ... ## $ Condition_2 : Factor w/ 8 levels &quot;Artery&quot;,&quot;Feedr&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ Bldg_Type : Factor w/ 5 levels &quot;OneFam&quot;,&quot;TwoFmCon&quot;,..: 1 1 1 1 1 1 5 5 5 1 ... ## $ House_Style : Factor w/ 8 levels &quot;One_and_Half_Fin&quot;,..: 3 3 3 3 8 8 3 3 3 8 ... ## $ Overall_Qual : Factor w/ 10 levels &quot;Very_Poor&quot;,&quot;Poor&quot;,..: 6 5 6 7 5 6 8 8 8 7 ... ## $ Overall_Cond : Factor w/ 10 levels &quot;Very_Poor&quot;,&quot;Poor&quot;,..: 5 6 6 5 5 6 5 5 5 5 ... ## $ Year_Built : int [1:2930] 1960 1961 1958 1968 1997 1998 2001 1992 1995 1999 ... ## $ Year_Remod_Add : int [1:2930] 1960 1961 1958 1968 1998 1998 2001 1992 1996 1999 ... ## $ Roof_Style : Factor w/ 6 levels &quot;Flat&quot;,&quot;Gable&quot;,..: 4 2 4 4 2 2 2 2 2 2 ... ## $ Roof_Matl : Factor w/ 8 levels &quot;ClyTile&quot;,&quot;CompShg&quot;,..: 2 2 2 2 2 2 2 2 2 2 ... ## $ Exterior_1st : Factor w/ 16 levels &quot;AsbShng&quot;,&quot;AsphShn&quot;,..: 4 14 15 4 14 14 6 7 6 14 ... ## $ Exterior_2nd : Factor w/ 17 levels &quot;AsbShng&quot;,&quot;AsphShn&quot;,..: 11 15 16 4 15 15 6 7 6 15 ... ## $ Mas_Vnr_Type : Factor w/ 5 levels &quot;BrkCmn&quot;,&quot;BrkFace&quot;,..: 5 4 2 4 4 2 4 4 4 4 ... ## $ Mas_Vnr_Area : num [1:2930] 112 0 108 0 0 20 0 0 0 0 ... ## $ Exter_Qual : Factor w/ 4 levels &quot;Excellent&quot;,&quot;Fair&quot;,..: 4 4 4 3 4 4 3 3 3 4 ... ## $ Exter_Cond : Factor w/ 5 levels &quot;Excellent&quot;,&quot;Fair&quot;,..: 5 5 5 5 5 5 5 5 5 5 ... ## $ Foundation : Factor w/ 6 levels &quot;BrkTil&quot;,&quot;CBlock&quot;,..: 2 2 2 2 3 3 3 3 3 3 ... ## $ Bsmt_Qual : Factor w/ 6 levels &quot;Excellent&quot;,&quot;Fair&quot;,..: 6 6 6 6 3 6 3 3 3 6 ... ## $ Bsmt_Cond : Factor w/ 6 levels &quot;Excellent&quot;,&quot;Fair&quot;,..: 3 6 6 6 6 6 6 6 6 6 ... ## $ Bsmt_Exposure : Factor w/ 5 levels &quot;Av&quot;,&quot;Gd&quot;,&quot;Mn&quot;,..: 2 4 4 4 4 4 3 4 4 4 ... ## $ BsmtFin_Type_1 : Factor w/ 7 levels &quot;ALQ&quot;,&quot;BLQ&quot;,&quot;GLQ&quot;,..: 2 6 1 1 3 3 3 1 3 7 ... ## $ BsmtFin_SF_1 : num [1:2930] 2 6 1 1 3 3 3 1 3 7 ... ## $ BsmtFin_Type_2 : Factor w/ 7 levels &quot;ALQ&quot;,&quot;BLQ&quot;,&quot;GLQ&quot;,..: 7 4 7 7 7 7 7 7 7 7 ... ## $ BsmtFin_SF_2 : num [1:2930] 0 144 0 0 0 0 0 0 0 0 ... ## $ Bsmt_Unf_SF : num [1:2930] 441 270 406 1045 137 ... ## $ Total_Bsmt_SF : num [1:2930] 1080 882 1329 2110 928 ... ## $ Heating : Factor w/ 6 levels &quot;Floor&quot;,&quot;GasA&quot;,..: 2 2 2 2 2 2 2 2 2 2 ... ## $ Heating_QC : Factor w/ 5 levels &quot;Excellent&quot;,&quot;Fair&quot;,..: 2 5 5 1 3 1 1 1 1 3 ... ## $ Central_Air : Factor w/ 2 levels &quot;N&quot;,&quot;Y&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ Electrical : Factor w/ 6 levels &quot;FuseA&quot;,&quot;FuseF&quot;,..: 5 5 5 5 5 5 5 5 5 5 ... ## $ First_Flr_SF : int [1:2930] 1656 896 1329 2110 928 926 1338 1280 1616 1028 ... ## $ Second_Flr_SF : int [1:2930] 0 0 0 0 701 678 0 0 0 776 ... ## $ Low_Qual_Fin_SF : int [1:2930] 0 0 0 0 0 0 0 0 0 0 ... ## $ Gr_Liv_Area : int [1:2930] 1656 896 1329 2110 1629 1604 1338 1280 1616 1804 ... ## $ Bsmt_Full_Bath : num [1:2930] 1 0 0 1 0 0 1 0 1 0 ... ## $ Bsmt_Half_Bath : num [1:2930] 0 0 0 0 0 0 0 0 0 0 ... ## $ Full_Bath : int [1:2930] 1 1 1 2 2 2 2 2 2 2 ... ## $ Half_Bath : int [1:2930] 0 0 1 1 1 1 0 0 0 1 ... ## $ Bedroom_AbvGr : int [1:2930] 3 2 3 3 3 3 2 2 2 3 ... ## $ Kitchen_AbvGr : int [1:2930] 1 1 1 1 1 1 1 1 1 1 ... ## $ Kitchen_Qual : Factor w/ 5 levels &quot;Excellent&quot;,&quot;Fair&quot;,..: 5 5 3 1 5 3 3 3 3 3 ... ## $ TotRms_AbvGrd : int [1:2930] 7 5 6 8 6 7 6 5 5 7 ... ## $ Functional : Factor w/ 8 levels &quot;Maj1&quot;,&quot;Maj2&quot;,..: 8 8 8 8 8 8 8 8 8 8 ... ## $ Fireplaces : int [1:2930] 2 0 0 2 1 1 0 0 1 1 ... ## $ Fireplace_Qu : Factor w/ 6 levels &quot;Excellent&quot;,&quot;Fair&quot;,..: 3 4 4 6 6 3 4 4 6 6 ... ## $ Garage_Type : Factor w/ 7 levels &quot;Attchd&quot;,&quot;Basment&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ Garage_Finish : Factor w/ 4 levels &quot;Fin&quot;,&quot;No_Garage&quot;,..: 1 4 4 1 1 1 1 3 3 1 ... ## $ Garage_Cars : num [1:2930] 2 1 1 2 2 2 2 2 2 2 ... ## $ Garage_Area : num [1:2930] 528 730 312 522 482 470 582 506 608 442 ... ## $ Garage_Qual : Factor w/ 6 levels &quot;Excellent&quot;,&quot;Fair&quot;,..: 6 6 6 6 6 6 6 6 6 6 ... ## $ Garage_Cond : Factor w/ 6 levels &quot;Excellent&quot;,&quot;Fair&quot;,..: 6 6 6 6 6 6 6 6 6 6 ... ## $ Paved_Drive : Factor w/ 3 levels &quot;Dirt_Gravel&quot;,..: 2 3 3 3 3 3 3 3 3 3 ... ## $ Wood_Deck_SF : int [1:2930] 210 140 393 0 212 360 0 0 237 140 ... ## $ Open_Porch_SF : int [1:2930] 62 0 36 0 34 36 0 82 152 60 ... ## $ Enclosed_Porch : int [1:2930] 0 0 0 0 0 0 170 0 0 0 ... ## $ Three_season_porch: int [1:2930] 0 0 0 0 0 0 0 0 0 0 ... ## $ Screen_Porch : int [1:2930] 0 120 0 0 0 0 0 144 0 0 ... ## $ Pool_Area : int [1:2930] 0 0 0 0 0 0 0 0 0 0 ... ## $ Pool_QC : Factor w/ 5 levels &quot;Excellent&quot;,&quot;Fair&quot;,..: 4 4 4 4 4 4 4 4 4 4 ... ## $ Fence : Factor w/ 5 levels &quot;Good_Privacy&quot;,..: 5 3 5 5 3 5 5 5 5 5 ... ## $ Misc_Feature : Factor w/ 6 levels &quot;Elev&quot;,&quot;Gar2&quot;,..: 3 3 2 3 3 3 3 3 3 3 ... ## $ Misc_Val : int [1:2930] 0 0 12500 0 0 0 0 0 0 0 ... ## $ Mo_Sold : int [1:2930] 5 6 6 4 3 6 4 1 3 6 ... ## $ Year_Sold : int [1:2930] 2010 2010 2010 2010 2010 2010 2010 2010 2010 2010 ... ## $ Sale_Type : Factor w/ 10 levels &quot;COD&quot;,&quot;Con&quot;,&quot;ConLD&quot;,..: 10 10 10 10 10 10 10 10 10 10 ... ## $ Sale_Condition : Factor w/ 6 levels &quot;Abnorml&quot;,&quot;AdjLand&quot;,..: 5 5 5 5 5 5 5 5 5 5 ... ## $ Sale_Price : int [1:2930] 215000 105000 172000 244000 189900 195500 213500 191500 236500 189000 ... ## $ Longitude : num [1:2930] -93.6 -93.6 -93.6 -93.6 -93.6 ... ## $ Latitude : num [1:2930] 42.1 42.1 42.1 42.1 42.1 ... ## - attr(*, &quot;spec&quot;)=List of 2 ## ..$ cols :List of 82 ## .. ..$ Order : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ PID : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ MS SubClass : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ MS Zoning : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Lot Frontage : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Lot Area : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Street : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Alley : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Lot Shape : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Land Contour : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Utilities : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Lot Config : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Land Slope : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Neighborhood : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Condition 1 : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Condition 2 : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Bldg Type : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ House Style : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Overall Qual : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Overall Cond : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Year Built : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Year Remod/Add : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Roof Style : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Roof Matl : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Exterior 1st : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Exterior 2nd : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Mas Vnr Type : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Mas Vnr Area : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Exter Qual : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Exter Cond : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Foundation : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Bsmt Qual : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Bsmt Cond : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Bsmt Exposure : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ BsmtFin Type 1 : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ BsmtFin SF 1 : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ BsmtFin Type 2 : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ BsmtFin SF 2 : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Bsmt Unf SF : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Total Bsmt SF : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Heating : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Heating QC : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Central Air : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Electrical : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ 1st Flr SF : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ 2nd Flr SF : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Low Qual Fin SF: list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Gr Liv Area : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Bsmt Full Bath : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Bsmt Half Bath : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Full Bath : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Half Bath : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Bedroom AbvGr : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Kitchen AbvGr : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Kitchen Qual : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ TotRms AbvGrd : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Functional : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Fireplaces : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Fireplace Qu : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Garage Type : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Garage Yr Blt : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Garage Finish : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Garage Cars : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Garage Area : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Garage Qual : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Garage Cond : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Paved Drive : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Wood Deck SF : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Open Porch SF : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Enclosed Porch : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ 3Ssn Porch : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Screen Porch : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Pool Area : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Pool QC : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Fence : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Misc Feature : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Misc Val : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Mo Sold : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Yr Sold : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Sale Type : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Sale Condition : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ SalePrice : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_integer&quot; &quot;collector&quot; ## ..$ default: list() ## .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;collector_guess&quot; &quot;collector&quot; ## ..- attr(*, &quot;class&quot;)= chr &quot;col_spec&quot; 5.1 Scatterplots Are the bigger houses more expensive? In base R, we can use the plot() function to generate this scatterplot with the first argument being the variable on the x-axis and the second argument being the variable on the y-axis. It’s OK but not nice. The plot() function provides a rich capability of customization by setting the graphical parameters. plot(amesdata$Gr_Liv_Area, amesdata$Sale_Price, col = &quot;red&quot;, xlab = &quot;Living Area&quot;, ylab = &quot;Sale Price&quot;, main = &quot;Sale Price vs. Living Area&quot;, pch = 1, #Shape of the points cex = 1) #Size of text and symbols Although the plot() function gets the work done, the ggplot2 package provides a superior user experience. It’s a member of the tidyverse package, you don’t need to install it separately if tidyverse was already installed. library(ggplot2) ggplot(data = amesdata) + geom_point(mapping = aes(x = Gr_Liv_Area, y = Sale_Price)) In a nutshell, ggplot2 implements the grammar of graphics, a coherent system for describing and building graphs. We always start with the function ggplot() with a data frame or tibble as its argument. To generate a scatterplot, you can add a layer using the + operator followed by the geom_point() function, which is one of the many available geoms in ggplot. Inside geom_point(), you need to set the value of the mapping argument. The mapping argument takes a functional form as mapping = aes(), where the aes is short for aesthetics. For example, you can use aes() to tell ggplot to use which variable on the x-axis, which variable on the y-axis. ggplot(data = amesdata) + geom_point(mapping = aes(Gr_Liv_Area, y = Sale_Price), color = &quot;red&quot;, shape = 2, size = 0.5, alpha = 0.3) #transparency level of the points Suppose we want to use different colors according to the different House_Style in the scatterplot. ggplot(data = amesdata) + geom_point(mapping = aes(x = Gr_Liv_Area, y = Sale_Price, color = House_Style), size = 1) In addition to color, you can also map a discrete variable to the size aesthetic. ggplot(data = amesdata) + geom_point(mapping = aes(x = Gr_Liv_Area, y = Sale_Price, size = House_Style), alpha = 0.5) Or ggplot(data = amesdata) + geom_point(mapping = aes(x = Gr_Liv_Area, y = Sale_Price, shape = Exter_Qual), alpha = 0.5, size = 2) and multiple mapping: ggplot(data = amesdata) + geom_point(mapping = aes(x = Gr_Liv_Area, y = Sale_Price, shape = Exter_Qual, color = Central_Air), alpha = 0.5, size = 2) 5.2 Smootlines ggplot(data = amesdata) + geom_smooth(mapping = aes(x = Gr_Liv_Area, y = Sale_Price), size = 1.5) ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; ggplot(data = amesdata) + geom_smooth(mapping = aes(x = Gr_Liv_Area, y = Sale_Price), size = 1.5, method = &quot;lm&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; And ggplot(data = amesdata) + geom_point(mapping = aes(x = Gr_Liv_Area, y = Sale_Price)) + geom_smooth(mapping = aes(x = Gr_Liv_Area, y = Sale_Price)) ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; # Or with global mapping ggplot(data = amesdata, mapping = aes(x = Gr_Liv_Area, y = Sale_Price, color = Central_Air)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; 5.3 Histograms &amp; Density How do we visualize continuous variables? One popular plot is called histograms. hist(amesdata$Sale_Price) And density with ggplot ggplot(data = amesdata, aes(x = Sale_Price)) + geom_histogram(aes(y = ..density..)) + geom_density(color = &quot;red&quot;, size = 1.5) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 5.4 Multiple plots fc &lt;- ggplot(data = amesdata, aes(x = Sale_Price)) + geom_histogram(aes(y = ..density..)) + geom_density(color = &quot;red&quot;, size = 1.5) fc + facet_wrap(&quot;Street&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Lables etc. fc + xlab(&quot;Sale Price&quot;) + ylab(&quot;Density&quot;) + ggtitle(&quot;Price vs. Area&quot;) + theme(axis.text = element_text(size = 25, color = &quot;red&quot;)) + theme(plot.title = element_text(size = 24, color = &quot;magenta&quot;, face = &quot;bold&quot;, hjust = 0.5)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 5.5 Add lines Let’s create some series (compounding series) of $1000: t &lt;- seq(0, 10, 1/4) A1 &lt;- 1000*(1+0.05)^t A2 &lt;- 1000*(1+0.03)^t A3 &lt;- 1000*(1+0.07)^t A4 &lt;- 1000*(1+0.1)^t plot(t, A1) Here is a simple but beautiful plot … So you may not want to use ggplot all the time: plot(t, A1, ylim = c(1000,2000), type = &quot;l&quot;, xlab = &quot;Time (in years)&quot;, ylab = &quot;Accumulated Value (in $)&quot;, main = &quot;Accumulated Value of $1000 Investment&quot;, col = &quot;black&quot;) lines(t, A2, type = &quot;l&quot;, col = &quot;blue&quot;, lty = 2, lwd = 2) lines(t, A3, type = &quot;l&quot;, col = &quot;red&quot;, lty = 3, lwd = 3) legend(&quot;bottomright&quot;, legend = c(&quot;3% Interest&quot;, &quot;5% Interest&quot;, &quot;7% Interest&quot;), col = c(&quot;blue&quot;, &quot;black&quot;, &quot;red&quot;), lty = c(2, 1, 3), bty = &quot;o&quot;, cex = 0.75) Or we can put them next to each other: par(mfrow=c(2,2), oma = c(0,0,2,0)) # puts 4 plots in one window (2x2) plot(t, A1, type = &quot;l&quot;, xlab = &quot;Time (in years)&quot;, ylab = &quot;AV - $&quot;, ylim = c(1000, 2500), main = &quot;(i = 0.05)&quot;) plot(t, A2, type = &quot;l&quot;, xlab = &quot;Time (in years)&quot;, ylab = &quot;AV - $&quot;, ylim = c(1000, 2500), main = &quot;(i = 0.03)&quot;) plot(t, A3, type = &quot;l&quot;, xlab = &quot;Time (in years)&quot;, ylab = &quot;AV - $&quot;, ylim = c(1000, 2500), main = &quot;(i = 0.07)&quot;) plot(t, A4, type = &quot;l&quot;, xlab = &quot;Time (in years)&quot;, ylab = &quot;AV - $&quot;, ylim = c(1000, 2500), main = &quot;(i = 0.1)&quot;) mtext(&quot;Accumulated Value of $1000 Investment&quot;, outer=TRUE, cex = 1.5, col=&quot;olivedrab&quot;) 5.6 Pairwise relationship R package corrplot provides a visual exploratory tool on correlation matrix that supports automatic variable reordering to help detect hidden patterns among variables. See more details here library(corrplot) ## corrplot 0.92 loaded M = cor(mtcars) corrplot(M, method = &#39;number&#39;) # colorful number corrplot(M) corrplot(M, order = &#39;AOE&#39;) corrplot.mixed(M, order = &#39;AOE&#39;) "],["data-management.html", "Chapter 6 Data Management 6.1 Filter 6.2 Arrange 6.3 Pipe 6.4 Select 6.5 Create &amp; group_by() 6.6 More tools", " Chapter 6 Data Management We will use the same data set, Ames Housing Price data, containing 165 observations and 12 features including the sale date and price. Suppose we want to find the houses that are sold in Jan 2010. You can use the function filter() in the dplyr package, a member of the tidyverse package. See more about dplyr here library(AmesHousing) amesdata &lt;- make_ames() 6.1 Filter We can use subsetting operations amesdata[amesdata$Year_Sold == 2010 &amp; amesdata$Mo_Sold == 1, ] ## # A tibble: 26 × 81 ## MS_Sub…¹ MS_Zo…² Lot_F…³ Lot_A…⁴ Street Alley Lot_S…⁵ Land_…⁶ Utili…⁷ Lot_C…⁸ ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 One_Sto… Reside… 43 5005 Pave No_A… Slight… HLS AllPub Inside ## 2 One_Sto… Reside… 105 11751 Pave No_A… Slight… Lvl AllPub Inside ## 3 Split_F… Reside… 85 10625 Pave No_A… Regular Lvl AllPub Inside ## 4 Two_Sto… Floati… 0 7500 Pave No_A… Regular Lvl AllPub Inside ## 5 Two_Sto… Reside… 102 12858 Pave No_A… Slight… Lvl AllPub Inside ## 6 One_Sto… Reside… 100 18494 Pave No_A… Slight… Lvl AllPub Corner ## 7 One_Sto… Reside… 43 3203 Pave No_A… Regular Lvl AllPub Inside ## 8 Two_Sto… Reside… 60 17433 Pave No_A… Modera… Lvl AllPub CulDSac ## 9 Two_Sto… Reside… 76 10142 Pave No_A… Slight… Lvl AllPub Inside ## 10 Two_Sto… Floati… 39 3515 Pave Paved Regular Lvl AllPub Inside ## # … with 16 more rows, 71 more variables: Land_Slope &lt;fct&gt;, Neighborhood &lt;fct&gt;, ## # Condition_1 &lt;fct&gt;, Condition_2 &lt;fct&gt;, Bldg_Type &lt;fct&gt;, House_Style &lt;fct&gt;, ## # Overall_Qual &lt;fct&gt;, Overall_Cond &lt;fct&gt;, Year_Built &lt;int&gt;, ## # Year_Remod_Add &lt;int&gt;, Roof_Style &lt;fct&gt;, Roof_Matl &lt;fct&gt;, ## # Exterior_1st &lt;fct&gt;, Exterior_2nd &lt;fct&gt;, Mas_Vnr_Type &lt;fct&gt;, ## # Mas_Vnr_Area &lt;dbl&gt;, Exter_Qual &lt;fct&gt;, Exter_Cond &lt;fct&gt;, Foundation &lt;fct&gt;, ## # Bsmt_Qual &lt;fct&gt;, Bsmt_Cond &lt;fct&gt;, Bsmt_Exposure &lt;fct&gt;, … Or we can use filter(): library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union dplyr::filter(amesdata, Year_Sold == 2010, Mo_Sold == 1) ## # A tibble: 26 × 81 ## MS_Sub…¹ MS_Zo…² Lot_F…³ Lot_A…⁴ Street Alley Lot_S…⁵ Land_…⁶ Utili…⁷ Lot_C…⁸ ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 One_Sto… Reside… 43 5005 Pave No_A… Slight… HLS AllPub Inside ## 2 One_Sto… Reside… 105 11751 Pave No_A… Slight… Lvl AllPub Inside ## 3 Split_F… Reside… 85 10625 Pave No_A… Regular Lvl AllPub Inside ## 4 Two_Sto… Floati… 0 7500 Pave No_A… Regular Lvl AllPub Inside ## 5 Two_Sto… Reside… 102 12858 Pave No_A… Slight… Lvl AllPub Inside ## 6 One_Sto… Reside… 100 18494 Pave No_A… Slight… Lvl AllPub Corner ## 7 One_Sto… Reside… 43 3203 Pave No_A… Regular Lvl AllPub Inside ## 8 Two_Sto… Reside… 60 17433 Pave No_A… Modera… Lvl AllPub CulDSac ## 9 Two_Sto… Reside… 76 10142 Pave No_A… Slight… Lvl AllPub Inside ## 10 Two_Sto… Floati… 39 3515 Pave Paved Regular Lvl AllPub Inside ## # … with 16 more rows, 71 more variables: Land_Slope &lt;fct&gt;, Neighborhood &lt;fct&gt;, ## # Condition_1 &lt;fct&gt;, Condition_2 &lt;fct&gt;, Bldg_Type &lt;fct&gt;, House_Style &lt;fct&gt;, ## # Overall_Qual &lt;fct&gt;, Overall_Cond &lt;fct&gt;, Year_Built &lt;int&gt;, ## # Year_Remod_Add &lt;int&gt;, Roof_Style &lt;fct&gt;, Roof_Matl &lt;fct&gt;, ## # Exterior_1st &lt;fct&gt;, Exterior_2nd &lt;fct&gt;, Mas_Vnr_Type &lt;fct&gt;, ## # Mas_Vnr_Area &lt;dbl&gt;, Exter_Qual &lt;fct&gt;, Exter_Cond &lt;fct&gt;, Foundation &lt;fct&gt;, ## # Bsmt_Qual &lt;fct&gt;, Bsmt_Cond &lt;fct&gt;, Bsmt_Exposure &lt;fct&gt;, … 6.2 Arrange Let’s find the 10 houses with the highest sale prices by year ar &lt;- arrange(amesdata, Year_Sold, desc(Sale_Price)) ar ## # A tibble: 2,930 × 81 ## MS_Sub…¹ MS_Zo…² Lot_F…³ Lot_A…⁴ Street Alley Lot_S…⁵ Land_…⁶ Utili…⁷ Lot_C…⁸ ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Two_Sto… Reside… 118 35760 Pave No_A… Slight… Lvl AllPub CulDSac ## 2 Two_Sto… Reside… 114 17242 Pave No_A… Slight… Lvl AllPub Inside ## 3 Two_Sto… Reside… 85 16056 Pave No_A… Slight… Lvl AllPub Inside ## 4 Two_Sto… Reside… 60 18062 Pave No_A… Slight… HLS AllPub CulDSac ## 5 Two_Sto… Reside… 82 16052 Pave No_A… Slight… Lvl AllPub CulDSac ## 6 Two_and… Reside… 90 22950 Pave No_A… Modera… Lvl AllPub Inside ## 7 One_Sto… Reside… 90 18261 Pave No_A… Slight… HLS AllPub Inside ## 8 One_Sto… Reside… 107 13891 Pave No_A… Regular Lvl AllPub Inside ## 9 Two_Sto… Reside… 59 16023 Pave No_A… Slight… HLS AllPub CulDSac ## 10 Two_Sto… Reside… 66 13682 Pave No_A… Modera… HLS AllPub CulDSac ## # … with 2,920 more rows, 71 more variables: Land_Slope &lt;fct&gt;, ## # Neighborhood &lt;fct&gt;, Condition_1 &lt;fct&gt;, Condition_2 &lt;fct&gt;, Bldg_Type &lt;fct&gt;, ## # House_Style &lt;fct&gt;, Overall_Qual &lt;fct&gt;, Overall_Cond &lt;fct&gt;, ## # Year_Built &lt;int&gt;, Year_Remod_Add &lt;int&gt;, Roof_Style &lt;fct&gt;, Roof_Matl &lt;fct&gt;, ## # Exterior_1st &lt;fct&gt;, Exterior_2nd &lt;fct&gt;, Mas_Vnr_Type &lt;fct&gt;, ## # Mas_Vnr_Area &lt;dbl&gt;, Exter_Qual &lt;fct&gt;, Exter_Cond &lt;fct&gt;, Foundation &lt;fct&gt;, ## # Bsmt_Qual &lt;fct&gt;, Bsmt_Cond &lt;fct&gt;, Bsmt_Exposure &lt;fct&gt;, … Or arr &lt;- amesdata[order(amesdata$Year_Sold, desc(amesdata$Sale_Price)), ] head(arr) ## # A tibble: 6 × 81 ## MS_SubC…¹ MS_Zo…² Lot_F…³ Lot_A…⁴ Street Alley Lot_S…⁵ Land_…⁶ Utili…⁷ Lot_C…⁸ ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Two_Stor… Reside… 118 35760 Pave No_A… Slight… Lvl AllPub CulDSac ## 2 Two_Stor… Reside… 114 17242 Pave No_A… Slight… Lvl AllPub Inside ## 3 Two_Stor… Reside… 85 16056 Pave No_A… Slight… Lvl AllPub Inside ## 4 Two_Stor… Reside… 60 18062 Pave No_A… Slight… HLS AllPub CulDSac ## 5 Two_Stor… Reside… 82 16052 Pave No_A… Slight… Lvl AllPub CulDSac ## 6 Two_and_… Reside… 90 22950 Pave No_A… Modera… Lvl AllPub Inside ## # … with 71 more variables: Land_Slope &lt;fct&gt;, Neighborhood &lt;fct&gt;, ## # Condition_1 &lt;fct&gt;, Condition_2 &lt;fct&gt;, Bldg_Type &lt;fct&gt;, House_Style &lt;fct&gt;, ## # Overall_Qual &lt;fct&gt;, Overall_Cond &lt;fct&gt;, Year_Built &lt;int&gt;, ## # Year_Remod_Add &lt;int&gt;, Roof_Style &lt;fct&gt;, Roof_Matl &lt;fct&gt;, ## # Exterior_1st &lt;fct&gt;, Exterior_2nd &lt;fct&gt;, Mas_Vnr_Type &lt;fct&gt;, ## # Mas_Vnr_Area &lt;dbl&gt;, Exter_Qual &lt;fct&gt;, Exter_Cond &lt;fct&gt;, Foundation &lt;fct&gt;, ## # Bsmt_Qual &lt;fct&gt;, Bsmt_Cond &lt;fct&gt;, Bsmt_Exposure &lt;fct&gt;, … 6.3 Pipe Pipes help us apply multiple operations sequentially on a given data. library(ggplot2) amesdata %&gt;% filter(Year_Sold == 2009, Mo_Sold == 1) %&gt;% arrange(Year_Built) %&gt;% ggplot(mapping = aes(x = Lot_Area, y = Sale_Price)) + geom_point() 6.4 Select How do we select variables based on some characteristics amesdata %&gt;% select(starts_with(&quot;Year&quot;), Sale_Price) ## # A tibble: 2,930 × 4 ## Year_Built Year_Remod_Add Year_Sold Sale_Price ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1960 1960 2010 215000 ## 2 1961 1961 2010 105000 ## 3 1958 1958 2010 172000 ## 4 1968 1968 2010 244000 ## 5 1997 1998 2010 189900 ## 6 1998 1998 2010 195500 ## 7 2001 2001 2010 213500 ## 8 1992 1992 2010 191500 ## 9 1995 1996 2010 236500 ## 10 1999 1999 2010 189000 ## # … with 2,920 more rows amesdata %&gt;% select(contains(&quot;Mo&quot;)) ## # A tibble: 2,930 × 2 ## Year_Remod_Add Mo_Sold ## &lt;int&gt; &lt;int&gt; ## 1 1960 5 ## 2 1961 6 ## 3 1958 6 ## 4 1968 4 ## 5 1998 3 ## 6 1998 6 ## 7 2001 4 ## 8 1992 1 ## 9 1996 3 ## 10 1999 6 ## # … with 2,920 more rows 6.5 Create &amp; group_by() We may want to create new variables as functions of the existing ones by mutate(): library(r02pro) library(tidyverse) amesdata %&gt;% select(Overall_Qual, Lot_Area, Sale_Price) %&gt;% mutate(ave_price = Sale_Price/Lot_Area) ## # A tibble: 2,930 × 4 ## Overall_Qual Lot_Area Sale_Price ave_price ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Above_Average 31770 215000 6.77 ## 2 Average 11622 105000 9.03 ## 3 Above_Average 14267 172000 12.1 ## 4 Good 11160 244000 21.9 ## 5 Average 13830 189900 13.7 ## 6 Above_Average 9978 195500 19.6 ## 7 Very_Good 4920 213500 43.4 ## 8 Very_Good 5005 191500 38.3 ## 9 Very_Good 5389 236500 43.9 ## 10 Good 7500 189000 25.2 ## # … with 2,920 more rows Can we summarize by groups? First let’s see an example for summarize: amesdata %&gt;% summarize(n_houses = n(), ave_liv_area = mean(Lot_Area), prob = c(0.25, 0.75), q_price = quantile(Sale_Price, c(0.25, 0.75), na.rm = TRUE)) ## # A tibble: 2 × 4 ## n_houses ave_liv_area prob q_price ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2930 10148. 0.25 129500 ## 2 2930 10148. 0.75 213500 Another amesdata %&gt;% group_by(Overall_Qual) %&gt;% summarize(n_houses = n(), ave_liv_area = mean(Lot_Area), ave_price = mean(Sale_Price), na.rm = TRUE) ## # A tibble: 10 × 5 ## Overall_Qual n_houses ave_liv_area ave_price na.rm ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 Very_Poor 4 15214. 48725 TRUE ## 2 Poor 13 9326. 52325. TRUE ## 3 Fair 40 9439. 83186. TRUE ## 4 Below_Average 226 8464. 106485. TRUE ## 5 Average 825 9996. 134753. TRUE ## 6 Above_Average 732 9788. 162130. TRUE ## 7 Good 602 10309. 205026. TRUE ## 8 Very_Good 350 10618. 270914. TRUE ## 9 Excellent 107 12777. 368337. TRUE ## 10 Very_Excellent 31 18071. 450217. TRUE 6.6 More tools 6.6.1 subset() any(is.na(amesdata)) ## [1] FALSE #Pay attention to subset(). This will be a time-saver sub &lt;- subset(amesdata, amesdata$Overall_Qual != &quot;Fair&quot;) dim(sub) ## [1] 2890 81 dim(amesdata) ## [1] 2930 81 #You can drop columns (variables) as well amesless = subset(amesdata, select = c(&quot;Sale_Type&quot;, &quot;Mo_Sold&quot;)) head(amesless) ## # A tibble: 6 × 2 ## Sale_Type Mo_Sold ## &lt;fct&gt; &lt;int&gt; ## 1 &quot;WD &quot; 5 ## 2 &quot;WD &quot; 6 ## 3 &quot;WD &quot; 6 ## 4 &quot;WD &quot; 4 ## 5 &quot;WD &quot; 3 ## 6 &quot;WD &quot; 6 However, look at the help(subset): “This is a convenience function intended for use interactively. For programming it is better to use the standard subsetting functions like [], and in particular the non-standard evaluation of argument subset can have unanticipated consequences”. 6.6.2 within() &amp; with() Here is an example to use within(): ana &lt;- within(amesdata, Sale_Price[Fence != 2] &lt;- 0) #which is a short cut of amesdata$Sale_Price[amesdata$Fence != 2] &lt;- 0 And with() mean(with(amesdata, Sale_Price[Mo_Sold == 5 &amp; Overall_Qual ==&quot;Good&quot;])) ## [1] 0 6.6.3 aggregate() The aggregate() function in R can be used to calculate summary statistics for a dataset. #create data frame df &lt;- data.frame(team=c(&#39;A&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;), position=c(&#39;G&#39;, &#39;G&#39;, &#39;F&#39;, &#39;G&#39;, &#39;F&#39;, &#39;F&#39;), points=c(99, 90, 86, 88, 95, 99), assists=c(33, 28, 31, 39, 34, 23), rebounds=c(30, 28, 24, 24, 28, 33)) df ## team position points assists rebounds ## 1 A G 99 33 30 ## 2 A G 90 28 28 ## 3 A F 86 31 24 ## 4 B G 88 39 24 ## 5 B F 95 34 28 ## 6 B F 99 23 33 #find mean points by team aggregate(df$points, by=list(df$team), FUN=mean) ## Group.1 x ## 1 A 91.66667 ## 2 B 94.00000 aggregate(df$points, by=list(df$team, df$position), FUN=mean) ## Group.1 Group.2 x ## 1 A F 86.0 ## 2 B F 97.0 ## 3 A G 94.5 ## 4 B G 88.0 We can also define our own functions mine &lt;- function(x){ return(sort(x)) } aggregate(df$points, by=list(df$assists), FUN=mine) ## Group.1 x ## 1 23 99 ## 2 28 90 ## 3 31 86 ## 4 33 99 ## 5 34 95 ## 6 39 88 "],["programing-basics.html", "Chapter 7 Programing basics 7.1 Conditional flows 7.2 Loops 7.3 The apply() family 7.4 Functions 7.5 source()", " Chapter 7 Programing basics In this section we see three main applications: conditional flows, loops, and functions, that are main pillars of any type of programming. 7.1 Conditional flows 7.1.1 if/Else The main syntax is as follows if (condition) { some R code } else { more R code } Here is a simple example: x &lt;- c(&quot;what&quot;,&quot;is&quot;,&quot;truth&quot;) if(&quot;Truth&quot; %in% x) { print(&quot;Truth is found&quot;) } else { print(&quot;Truth is not found&quot;) } ## [1] &quot;Truth is not found&quot; How about this: x &lt;- c(1, 4, 4) a &lt;- 3 #Here is a nice if/Else if(length(x[x == a]) &gt; 0) { print(paste(&quot;x has&quot;, length(x[x==a]), a)) } else { print(paste(&quot;x doesn&#39;t have any&quot;, a)) } ## [1] &quot;x doesn&#39;t have any 3&quot; #Another one with pipping a &lt;- 4 if(a %in% x) { print(paste(&quot;x has&quot;, length(x[x==a]), a)) } else { print(paste(&quot;x doesn&#39;t have any&quot;, a)) } ## [1] &quot;x has 2 4&quot; 7.1.2 Nested conditions #Change the numbers to see all conditions x &lt;- 0 y &lt;- 4 if (x == 0 &amp; y!= 0) { print(&quot;a number cannot be divided by zero&quot;) } else if (x == 0 &amp; y == 0) { print(&quot;a zero cannot be divided by zero&quot;) } else { a &lt;- y/x print(paste(&quot;y/x = &quot;, a)) } ## [1] &quot;a number cannot be divided by zero&quot; Building multiple conditions without else (it’s a silly example!): z &lt;- 0 w &lt;- 4 x &lt;- 5 y &lt;- 3 if(z &gt; w) print(&quot;z is bigger than w&quot;) if(w &gt; z) print(&quot;w is bigger than z&quot;) ## [1] &quot;w is bigger than z&quot; if(x &gt; y) print(&quot;x is bigger than y&quot;) ## [1] &quot;x is bigger than y&quot; if(y &gt; x) print(&quot;y is bigger than x&quot;) if(z &gt; x) print(&quot;z is bigger than x&quot;) if(x &gt; z) print(&quot;x is bigger than z&quot;) ## [1] &quot;x is bigger than z&quot; if(w &gt; y) print(&quot;w is bigger than y&quot;) ## [1] &quot;w is bigger than y&quot; if(y &gt; w) print(&quot;y is bigger than w&quot;) 7.1.3 Simpler ifelse A simpler, one-line ifelse: #Change the numbers x &lt;- 0 y &lt;- 4 ifelse (x &gt; y, &quot;x is bigger than y&quot;, &quot;y is bigger than x&quot;) ## [1] &quot;y is bigger than x&quot; #Better (ifelse will fail if x = y. Try it!) ifelse (x == y, &quot;x is the same as y&quot;, ifelse(x &gt; y, &quot;x is bigger than y&quot;, &quot;y is bigger than x&quot;)) ## [1] &quot;y is bigger than x&quot; A simpler, without else! z &lt;- 0 w &lt;- 4 if(z &gt; w) print(&quot;w is bigger than z&quot;) #Change the numbers x &lt;- 5 y &lt;- 3 if(x &gt; y) print(&quot;x is bigger than y&quot;) ## [1] &quot;x is bigger than y&quot; #See that both of them moves to the next line. The ifelse() function only allows for one “if” statement, two cases. You could add nested “if” statements, but that’s just a pain, especially if the 3+ conditions you want to use are all on the same level, conceptually. Is there a way to specify multiple conditions at the same time? #Let&#39;s create a data frame: df &lt;- data.frame(&quot;name&quot;=c(&quot;Kaija&quot;, &quot;Ella&quot;, &quot;Andis&quot;), &quot;test1&quot; = c(FALSE, TRUE, TRUE), &quot;test2&quot; = c(FALSE, FALSE, TRUE)) df ## name test1 test2 ## 1 Kaija FALSE FALSE ## 2 Ella TRUE FALSE ## 3 Andis TRUE TRUE Suppose we want separate the people into three groups: People who passed both tests: Group A People who passed one test: Group B People who passed neither test: Group C dplyr has a function for exactly this purpose: case_when(). library(dplyr) df &lt;- df %&gt;% mutate(group = case_when(test1 &amp; test2 ~ &quot;A&quot;, # both tests: group A xor(test1, test2) ~ &quot;B&quot;, # one test: group B !test1 &amp; !test2 ~ &quot;C&quot; # neither test: group C )) df ## name test1 test2 group ## 1 Kaija FALSE FALSE C ## 2 Ella TRUE FALSE B ## 3 Andis TRUE TRUE A 7.2 Loops What would you do if you needed to execute a block of code multiple times? In general, statements are executed sequentially. A loop statement allows us to execute a statement or group of statements multiple times and the following is the general form of a loop statement in most programming languages. There are 3 main loop types: while(), for(), repeat(). Here are some examples for for() loop: x &lt;- c(3, -1, 4, 2, 10, 5) for (i in 1:length(x)) { x[i] &lt;- x[i] * 2 } x ## [1] 6 -2 8 4 20 10 Note that this just for an example. If we want to multiply each element of a vector by 2, a loop isn’t the best way. Although it is very normal in many programming languages, we would simply use a vectorized operation in R. x &lt;- c(3, -1, 4, 2, 10, 5) x &lt;- x * 2 x ## [1] 6 -2 8 4 20 10 7.2.1 Conditional loops But some times it would be very handy. If the element in \\(x &gt; 3\\), multiply it with the subsequent element: x &lt;- c(3, -1, 0, 2, 10, 5) x_new &lt;- c() #empty container for (i in 1:(length(x)-1)) { ifelse(x[i] &gt; 3, x_new[i] &lt;- x[i] * x[i + 1], x_new[i] &lt;- 0) } x ## [1] 3 -1 0 2 10 5 x_new ## [1] 0 0 0 0 50 Inside the if and else clause, you can use next and break to further control the flow. The next function goes directly to the next loop cycle, while break jumped out of the current loop. x &lt;- c(9, -1, 0, 5, -7, 16, 22) zn &lt;- c() for(i in 1:length(x)){ if(x[i] &lt; 0){ next } zn &lt;- c(zn, sqrt(x[i])) } zn ## [1] 3.000000 0.000000 2.236068 4.000000 4.690416 Inside the if and else clause, you can use next and break to further control the flow. The next function goes directly to the next loop cycle, while break jumped out of the current loop. x &lt;- c(9, 1, 0, 5, 7, 16, 22) bn &lt;- c() for(i in 1:length(x)){ if(x[i] &gt; 10){ break } bn &lt;- c(bn, sqrt(x[i])) } bn ## [1] 3.000000 1.000000 0.000000 2.236068 2.645751 7.2.2 while() and repeat() Here are some examples for while() loop: # Let&#39;s use our first example x &lt;- 3 cnt &lt;- 1 while (cnt &lt; 11) { x = x * 2 cnt = cnt + 1 } x ## [1] 3072 Here are some examples for repeat() loop: # Let&#39;s use our first example x &lt;- 3 cnt &lt;- 1 repeat { x = x * 2 cnt = cnt + 1 if(cnt &gt; 10) break } x ## [1] 3072 7.2.3 Nested loops It is also common to put one loop inside another one. Let’s say we want to create a 5x5 matrix where each element \\(A_{i j}=i+j\\) A &lt;- matrix(0, 5, 5) #initialize the matrix A for (i in 1:5) #loop over index i for (j in 1:5){ #loop over index j A[i, j] &lt;- i + j #set the (i, j)-th element of A } A ## [,1] [,2] [,3] [,4] [,5] ## [1,] 2 3 4 5 6 ## [2,] 3 4 5 6 7 ## [3,] 4 5 6 7 8 ## [4,] 5 6 7 8 9 ## [5,] 6 7 8 9 10 7.2.4 outer() outer() takes two vectors and a function (that itself takes two arguments) and builds a matrix by calling the given function for each combination of the elements in the two vectors. x &lt;- c(0, 1, 2) y &lt;- c(0, 1, 2, 3, 4) m &lt;- outer ( y, # First dimension: the columns (y) x, # Second dimension: the rows (x) function (x, y) x+2*y ) m ## [,1] [,2] [,3] ## [1,] 0 2 4 ## [2,] 1 3 5 ## [3,] 2 4 6 ## [4,] 3 5 7 ## [5,] 4 6 8 In place of the function, an operator can be given, which makes it easy to create a matrix with simple calculations (such as multiplying): m &lt;- outer(c(10, 20, 30, 40), c(2, 4, 6), &quot;*&quot;) m ## [,1] [,2] [,3] ## [1,] 20 40 60 ## [2,] 40 80 120 ## [3,] 60 120 180 ## [4,] 80 160 240 It becomes very handy when we build a polynomial model: x &lt;- sample(0:20, 10, replace = TRUE) x ## [1] 14 2 4 18 9 9 15 5 4 12 m &lt;- outer(x, 1:4, &quot;^&quot;) m ## [,1] [,2] [,3] [,4] ## [1,] 14 196 2744 38416 ## [2,] 2 4 8 16 ## [3,] 4 16 64 256 ## [4,] 18 324 5832 104976 ## [5,] 9 81 729 6561 ## [6,] 9 81 729 6561 ## [7,] 15 225 3375 50625 ## [8,] 5 25 125 625 ## [9,] 4 16 64 256 ## [10,] 12 144 1728 20736 We can also use outer() for this example outer(1:5, 1:5, &quot;+&quot;) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 2 3 4 5 6 ## [2,] 3 4 5 6 7 ## [3,] 4 5 6 7 8 ## [4,] 5 6 7 8 9 ## [5,] 6 7 8 9 10 # Or outer(1:4, 1:4, function(i, j){0.5^{abs(i-j)}}) ## [,1] [,2] [,3] [,4] ## [1,] 1.000 0.50 0.25 0.125 ## [2,] 0.500 1.00 0.50 0.250 ## [3,] 0.250 0.50 1.00 0.500 ## [4,] 0.125 0.25 0.50 1.000 7.3 The apply() family The apply() family is one of the R base packages and is populated with functions to manipulate slices of data from matrices, arrays, lists and data frames in a repetitive way. These functions allow crossing the data in a number of ways and avoid explicit use of loop constructs. They act on an input list, matrix or array and apply a named function with one or several optional arguments. The family is made up of the apply(), lapply() , sapply(), vapply(), mapply(), rapply(), and tapply() functions. 7.3.1 apply() The R base manual tells you that it’s called as follows: apply(X, MARGIN, FUN, ...), where, X is an array or a matrix if the dimension of the array is 2; MARGIN is a variable defining how the function is applied: when MARGIN=1, it applies over rows, whereas with MARGIN=2, it works over columns. Note that when you use the construct MARGIN=c(1,2), it applies to both rows and columns; and FUN, which is the function that you want to apply to the data. It can be any R function, including a User Defined Function (UDF). # Construct a 5x6 matrix X &lt;- matrix(rnorm(30), nrow=5, ncol=6) # Sum the values of each column with `apply()` apply(X, 2, sum) ## [1] 0.6119467 0.5547059 5.2032793 3.3787016 0.5431877 2.4084681 apply(X, 2, length) ## [1] 5 5 5 5 5 5 apply(X, 1, length) ## [1] 6 6 6 6 6 apply(X, 2, function (x) length(x)-1) ## [1] 4 4 4 4 4 4 #If you don’t want to write a function inside of the arguments len &lt;- function(x){ length(x)-1 } apply(X,2, len) ## [1] 4 4 4 4 4 4 #It can also be used to repeat a function on cells within a matrix X_new &lt;- apply(X[1:2,], 1, function(x) x+1) X_new ## [,1] [,2] ## [1,] 0.6433165 1.4286731 ## [2,] 1.9854933 0.5690186 ## [3,] 0.7784161 1.7768329 ## [4,] 1.1961836 2.8538337 ## [5,] 1.2639224 0.5577531 ## [6,] 1.7173065 2.9555428 Since apply() is used only for matrices, if you apply apply() to a data frame, it first coerces your data.frame to an array which means all the columns must have the same type. Depending on your context, this could have unintended consequences. For a safer practice in data frames, we can use lappy() and sapply(): 7.3.2 lapply() You want to apply a given function to every element of a list and obtain a list as a result. When you execute ?lapply, you see that the syntax looks like the apply() function. The difference is that it can be used for other objects like data frames, lists or vectors. And the output returned is a list (which explains the “l” in the function name), which has the same number of elements as the object passed to it. lapply() function does not need MARGIN. A&lt;-c(1:9) B&lt;-c(1:12) C&lt;-c(1:15) my.lst&lt;-list(A,B,C) lapply(my.lst, sum) ## [[1]] ## [1] 45 ## ## [[2]] ## [1] 78 ## ## [[3]] ## [1] 120 7.3.3 sapply() sapply works just like lapply, but will simplify the output if possible. This means that instead of returning a list like lapply, it will return a vector instead if the data is simplifiable. A&lt;-c(1:9) B&lt;-c(1:12) C&lt;-c(1:15) my.lst&lt;-list(A,B,C) sapply(my.lst, sum) ## [1] 45 78 120 7.3.4 tapply() Sometimes you may want to perform the apply function on some data, but have it separated by factor. In that case, you should use tapply. Let’s take a look at the information for tapply. X &lt;- matrix(c(1:10, 11:20, 21:30), nrow = 10, ncol = 3) tdata &lt;- as.data.frame(cbind(c(1,1,1,1,1,2,2,2,2,2), X)) tdata ## V1 V2 V3 V4 ## 1 1 1 11 21 ## 2 1 2 12 22 ## 3 1 3 13 23 ## 4 1 4 14 24 ## 5 1 5 15 25 ## 6 2 6 16 26 ## 7 2 7 17 27 ## 8 2 8 18 28 ## 9 2 9 19 29 ## 10 2 10 20 30 tapply(tdata$V2, tdata$V1, mean) ## 1 2 ## 3 8 What we have here is an important tool: We have a conditional mean of column 2 (V2) with respect to column 1 (V1). You can use tapply to do some quick summary statistics on a variable split by condition. summary &lt;- tapply(tdata$V2, tdata$V1, function(x) c(mean(x), sd(x))) summary ## $`1` ## [1] 3.000000 1.581139 ## ## $`2` ## [1] 8.000000 1.581139 7.3.5 mapply() mapply() would be used to create a new variable. For example, using dataset tdata, we could divide one column by another column to create a new value. This would be useful for creating a ratio of two variables as shown in the example below. tdata$V5 &lt;- mapply(function(x, y) x/y, tdata$V2, tdata$V4) tdata$V5 ## [1] 0.04761905 0.09090909 0.13043478 0.16666667 0.20000000 0.23076923 ## [7] 0.25925926 0.28571429 0.31034483 0.33333333 7.4 Functions An R function is created by using the keyword function. Let’s write our first function: first &lt;- function(a){ b &lt;- a ^ 2 return(b) } first(1675) ## [1] 2805625 Let’s have a function that find the z-score (standardization). That’s subtracting the sample mean, and dividing by the sample standard deviation. \\[ \\frac{x-\\overline{x}}{s} \\] z_score &lt;- function(x){ return((x - mean(x))/sd(x)) } set.seed(1) x &lt;- rnorm(10, 3, 30) z &lt;- z_score(x) z ## [1] -0.97190653 0.06589991 -1.23987805 1.87433300 0.25276523 -1.22045645 ## [7] 0.45507643 0.77649606 0.56826358 -0.56059319 Lets create a function that prints the factorials: fact &lt;- function(a){ b &lt;- 1 for (i in 1:(a-1)) { b &lt;- b*(i+1) } b } fact(5) ## [1] 120 Creating loops is an act of art and requires very careful thinking. The same loop can be done by many different structures. And it always takes more time to understand somebody else’s loop than your own! 7.5 source() You can use the source() function in R to reuse functions that you create in another R script. The function uses the following basic syntax: source(\"path/to/some/file.R\") Suppose we have the following R script called some_functions.R that contains two simple user-defined functions: divide_by_two &lt;- function(x) { return(x/2) } multiply_by_three &lt;- function(x) { return(x*3) } Now suppose we’re currently working with some R script called main_script.R. Assuming some_functions.R and main_script.R are located within the same folder, we can use source at the top of our main_script.R to allow us to use the functions we defined in the some_functions.R script: source(&quot;some_functions.R&quot;) df &lt;- data.frame(team=c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;), points=c(14, 19, 22, 15, 30, 40)) df$half_points &lt;- divide_by_two(df$points) df$triple_points &lt;- multiply_by_three(df$points) df ## team points half_points triple_points ## 1 A 14 7.0 42 ## 2 B 19 9.5 57 ## 3 C 22 11.0 66 ## 4 D 15 7.5 45 ## 5 E 30 15.0 90 ## 6 F 40 20.0 120 We can use as many source functions as we’d like if we want to reuse functions defined in several different scripts. "],["simulation-in-r.html", "Chapter 8 Simulation in R 8.1 Sampling in R: sample() 8.2 Random number generating with probablity distributions 8.3 Simulation for statistical inference 8.4 Creataing data with a Data Generating Model (DGM) 8.5 Bootstrapping 8.6 Monty Hall - Fun example", " Chapter 8 Simulation in R In this chapter, we will learn how to simulate data and illustrate their use in several examples. More specifically we’ll cover the following subjects: Sampling in R: sample(), Random number generating with probability distributions, Simulation for statistical inference, Creating data with a DGM, Bootstrapping, Power of simulation - A fun example. Why would we want to simulate data? Why not just use real data? Because with real data, we don’t know what the right answer is. Suppose we use real data and we apply a method to extract information, how do we know that we applied the method correctly? Now suppose we create artificial data by simulating a “Data Generating Model”. Since we can know the correct answer, we can check whether or not our methods work to extract the information we wish to have. If our method is correct, than we can apply it to real data. 8.1 Sampling in R: sample() Let’s play with sample() for simple random sampling. We will see the arguments of sample() function. sample(c(&quot;H&quot;,&quot;T&quot;), size = 8, replace = TRUE) # fair coin ## [1] &quot;T&quot; &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;T&quot; &quot;H&quot; &quot;T&quot; &quot;H&quot; sample(1:6, size = 2, replace = TRUE, prob=c(3,3,3,4,4,4)) ## [1] 1 5 #let&#39;s do it again sample(c(&quot;H&quot;,&quot;T&quot;), size = 8, replace = TRUE) # fair coin ## [1] &quot;H&quot; &quot;T&quot; &quot;T&quot; &quot;H&quot; &quot;T&quot; &quot;H&quot; &quot;H&quot; &quot;T&quot; sample(1:6, size = 2, replace = TRUE, prob=c(3,3,3,4,4,4)) ## [1] 1 3 The results are different. If we use set.seed() then we can get the same results each time. Lets try now: set.seed(123) sample(c(&quot;H&quot;,&quot;T&quot;), size = 8, replace = TRUE) # fair coin ## [1] &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;T&quot; &quot;H&quot; &quot;T&quot; &quot;T&quot; &quot;T&quot; sample(1:6, size = 2, replace = TRUE, prob=c(3,3,3,4,4,4)) ## [1] 4 4 #let&#39;s do it again set.seed(123) sample(c(&quot;H&quot;,&quot;T&quot;), size = 8, replace = TRUE) # fair coin ## [1] &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;T&quot; &quot;H&quot; &quot;T&quot; &quot;T&quot; &quot;T&quot; sample(1:6, size = 2, replace = TRUE, prob=c(3,3,3,4,4,4)) ## [1] 4 4 We use replace=TRUE to override the default sample without replacement. This means the same thing can get selected from the population multiple times. And, prob= to sample elements with different probabilities, e.g. over sample based on some factor. The set.seed() function allow you to make a reproducible set of random numbers. Let’s see the difference. x &lt;- 1:12 # a random permutation set.seed(123) sample(x) ## [1] 3 12 10 2 6 11 5 4 9 8 1 7 # This shuffles the numbers set.seed(123) sample(x, replace = TRUE) ## [1] 3 3 10 2 6 11 5 4 6 9 10 11 # This shuffles the numbers and replacing them More… # sample()&#39;s surprise -- example x &lt;- 1:10 sample(x[x &gt; 3]) # length 2 ## [1] 8 6 9 4 7 10 5 sample(x[x &gt; 9]) # oops -- length 10! So this doesn&#39;t work ## [1] 3 8 2 7 9 1 6 10 4 5 sample(x[x &gt; 10]) # length 0 ## integer(0) Here is an example: let’s generate 501 coin flips. In the true model, this should generate heads half of the time, and tails half of the time. set.seed(123) coins &lt;- sample(c(&quot;Heads&quot;,&quot;Tails&quot;), 501, replace = TRUE) Now let’s take that data as given and analyze it in our standard way! The proportion of heads is: mean(coins==&#39;Heads&#39;) ## [1] 0.5209581 barplot(prop.table(table(coins)), col = c(&quot;lightskyblue3&quot;,&quot;mistyrose3&quot;), cex.axis = 0.8, cex.names = 0.8) So what’s our conclusion? We came to the conclusion that the true model generates heads 0.493014 of the time. But it is NOT 0.50 , so pretty close, but not exact. Did this whole thing work or not? What if it always errs on the same side? In other words, what if it’s always bias towards heads in every sample with 501 flips? We will do our first simulation to answer it momentarily. One more useful application: sample(letters, 10, replace = TRUE) ## [1] &quot;p&quot; &quot;z&quot; &quot;o&quot; &quot;s&quot; &quot;c&quot; &quot;n&quot; &quot;a&quot; &quot;x&quot; &quot;a&quot; &quot;p&quot; 8.2 Random number generating with probablity distributions Here are the common probability distributions in R. Search help in R for more detail. beta(shape1, shape2, ncp), binom(size, prob), chisq(df, ncp), exp(rate), gamma(shape, scale), logis(location, scale), norm(mean, sd), pois(lambda), t(df, ncp), unif(min, max), dnorm(x,) returns the density or the value on the y-axis of a probability distribution for a discrete value of x, pnorm(q,) returns the cumulative density function (CDF) or the area under the curve to the left of an x value on a probability distribution curve, qnorm(p,) returns the quantile value, i.e. the standardized z value for x, rnorm(n,) returns a random simulation of size n rnorm(6) # 6 std nrml distribution values ## [1] -0.2645952 -0.9472983 0.7395213 0.8967787 -0.3460009 -1.7820571 rnorm(10, mean = 50, sd = 19) # set parameters ## [1] 58.83389 12.93042 40.19385 59.29253 67.13847 62.16690 68.07297 38.61666 ## [9] 24.71680 38.74801 runif(n = 10, min = 0, max = 1) #uniform distribution ## [1] 0.96415257 0.08146656 0.85436475 0.80223822 0.38517360 0.32759740 ## [7] 0.20493870 0.56938266 0.88805519 0.52971409 rpois(n = 10, lambda = 15) # Poisson distribution ## [1] 15 15 6 17 16 13 15 15 15 21 # toss coin 8 times using binomial distribution rbinom(n = 8, size = 1, p = 0.5) ## [1] 0 0 1 0 1 1 1 0 rbinom(8,1,.5) # args correct order ## [1] 1 0 0 1 1 1 1 0 # 18 trials, sample size 10, prob success =.2 rbinom(18, 10, 0.2) ## [1] 5 1 0 4 2 1 4 0 1 3 1 1 1 3 1 3 1 1 Can we replicate our coin-flip example here with probability distributions? Yes, we can! set.seed(123) coins &lt;- rbinom(n = 501, size = 1, p = 0.5) mean(coins==0) ## [1] 0.5309381 barplot(prop.table(table(coins)), col = c(&quot;lightskyblue3&quot;,&quot;mistyrose3&quot;), cex.axis = 0.8, cex.names = 0.8) 8.3 Simulation for statistical inference Let’s predict number of girls in 400 births, where probability of female birth is 48.8% n.girls &lt;- rbinom(1, 400, 0.488) n.girls ## [1] 201 n.girls/400 ## [1] 0.5025 Now, to get distribution of the simulations, repeat the simulation many times. n.sims &lt;- 1000 n.girls &lt;- rbinom(n.sims, 400, .488) hist(n.girls, col = &quot;slategray3&quot;, cex.axis = 0.75) mean(n.girls)/400 ## [1] 0.4872775 This is called as sampling distribution. Can we do same thing with a loop? n.sims &lt;- 1000 n.girls &lt;- rep(NA, n.sims) # create vector to store simulations for (i in 1:n.sims){ n.girls[i] &lt;- rbinom(1, 400, 0.488) } hist(n.girls, col = &quot;lavender&quot;, cex.axis = 0.75) Let’s apply a similar simulation to our coin flipping. n.sims &lt;- 1000 n.heads &lt;- rep(NA, n.sims) # create vector to store simulations for (i in 1:n.sims){ n.heads[i] &lt;- mean(rbinom(n = 501, size = 1, p = 0.5)) } hist(n.heads, col=&quot;aliceblue&quot;, cex.axis = 0.75) mean(n.heads) ## [1] 0.4997705 Here is another way for the same simulation: n.heads &lt;- replicate(1000, mean(rbinom(n = 501, size = 1, p = 0.5))) hist(n.heads, col=&quot;lightpink&quot;,cex.axis = 0.75) mean(n.heads) ## [1] 0.4987265 What’s the 95% confidence interval for the mean? sd &lt;- sd(n.heads) CI95 &lt;- c(-2*sd+mean(n.heads), 2*sd+mean(n.heads)) CI95 ## [1] 0.4538446 0.5436085 What happens if we use a “wrong” estimator for the mean, like sum(heads)/300? n.sims &lt;- 1000 n.heads &lt;- rep(NA, n.sims) # create vector to store simulations for (i in 1:n.sims){ n.heads[i] &lt;- sum(rbinom(n = 501, size = 1, p = 0.5))/300 } mean(n.heads) ## [1] 0.83496 Because we are working with a simulation, identifying that the result from this incorrect estimator is wrong becomes easy. 8.4 Creataing data with a Data Generating Model (DGM) One of the major tasks of statistics is to obtain information about populations. In most of cases, the population is unknown and the only thing that is known for the researcher is a finite subset of observations drawn from the population. The main aim of the statistical analysis is to obtain information about the population through analysis of the sample. Since very little information is known about the population characteristics, one has to establish some assumptions about the behavior of this unknown population. For example, for a regression analysis, we can state that the whole population regression function (PRF) is a linear function of the different values of \\(X\\). One important issue related to the PRF is the error term (\\(u_i\\)) in the regression equation. For a pair of realizations \\((x_i,y_i)\\) from the random variables \\((X,Y)\\), we can write the following equalities: \\[ y_{i}=E\\left(Y | X=x_{i}\\right)+u_{i}=\\alpha+\\beta x_{i}+u_{i} \\] and \\[ E\\left(u | X=x_{i}\\right)=0 \\] This result implies that for \\(X=x_i\\), the divergences of all values of \\(Y\\) with respect to the conditional expectation \\(E(Y\\vert X=x_i)\\) are averaged out. There are several reasons for the existence of the error term in the regression: (1) the error term is taking into account variables which are not in the model; (2) we do not have great confidence about the correctness of the model; and (3) we do not know if there are measurement errors in the variables. In a regression analysis, the PRF is a Data Generating Model for \\(y_i\\), which is unknown to us. Because it is unknown, we must try to learn about it from a sample since that is the only available data for us. If we assume that there is a specific PRF that generates the data, then given any estimator of \\(\\alpha\\) and \\(\\beta\\), namely \\(\\hat{\\beta}\\) and \\(\\hat{\\alpha}\\), we can estimate them from our sample with the sample regression function (SRF): \\[ \\hat{y}_{i}=\\hat{\\alpha}+\\hat{\\beta} x_{i}, \\quad i=1, \\cdots, n \\] The relationship between the PRF and SRF is: \\[ y_{i}=\\hat{y}_{i}+\\hat{u}_{i}, \\quad i=1, \\cdots, n \\] where \\(\\hat{u_i}\\) is denoted the residuals from SRF. With a data generating process (DGP) at hand, it is possible to create new simulated data. With \\(\\alpha\\), \\(\\beta\\) and the vector of exogenous variables \\(X\\) (fixed), a sample of size \\(n\\) can be used to obtain \\(N\\) values of \\(Y\\) with random variable \\(u\\). This yields one complete population of size \\(N\\). Note that this artificially generated set of data could be viewed as an example of real-world data that a researcher would be faced with when dealing with the kind of estimation problem this model represents. Note especially that the set of data obtained depends crucially on the particular set of error terms drawn. A different set of error terms would create a different data set of \\(Y\\) for the same problem. With the artificial data we generated, DGM is now known and the whole population is accessible. That is, we can test many models on different samples drawn from this population in order to see whether their inferential properties are in line with DGM. We’ll have several examples below. Here is our DGM: \\[ Y_{i}=\\beta_{1}+\\beta_{2} X_{2 i}+\\beta_{3} X_{3 i}+\\beta_{4} X_{2 i} X_{3 i}+\\beta_{5} X_{5 i}, \\] with the following coefficient vector: \\(\\beta = (12, -0.7, 34, -0.17, 5.4)\\). Moreover \\(x_2\\) is binary variable with values of 0 and 1 and \\(x_5\\) and \\(x_3\\) are highly correlated with \\(\\rho = 0.65\\). When we add the error term, \\(u\\), which is independently and identically (i.i.d) distributed with \\(N(0,1)\\), we can get the whole population of 10,000 observations. DGM plus the error term is called the data generating process (DGP) library(MASS) N &lt;- 10000 x_2 &lt;- sample(c(0,1), N, replace = TRUE) #Dummy variable #mvrnorm() creates a matrix of correlated variables X_corr &lt;- mvrnorm(N, mu = c(0,0), Sigma = matrix(c(1,0.65,0.65,1), ncol = 2), empirical = TRUE) #We can check their correlation cor(X_corr) ## [,1] [,2] ## [1,] 1.00 0.65 ## [2,] 0.65 1.00 #Each column is one of our variables x_3 &lt;- X_corr[,1] x_5 &lt;- X_corr[,2] #interaction x_23 &lt;- x_2*x_3 # Now DGM beta &lt;- c(12, -0.7, 34, -0.17, 5.4) dgm &lt;- beta[1] + beta[2]*x_2 + beta[3]*x_3 + beta[4]*x_23 + beta[5]*x_5 #And our Yi y &lt;- dgm + rnorm(N,0,1) pop &lt;- data.frame(y, x_2, x_3, x_23, x_5) str(pop) ## &#39;data.frame&#39;: 10000 obs. of 5 variables: ## $ y : num -37.09 8.41 12.84 44.55 31.87 ... ## $ x_2 : num 0 0 1 1 0 1 1 1 0 0 ... ## $ x_3 : num -1.3163 -0.1002 0.0558 0.7737 0.6297 ... ## $ x_23: num 0 0 0.0558 0.7737 0 ... ## $ x_5 : num -0.6134 -0.0465 -0.0857 1.5022 -0.3612 ... #Here is new thing/trick to learn #for better looking tables install.packages(&quot;stargazer&quot;) library(stargazer) stargazer(pop, type = &quot;text&quot;, title = &quot;Descriptive Statistics&quot;, digits = 1, out = &quot;table1.text&quot;) ## ## Descriptive Statistics ## ============================================ ## Statistic N Mean St. Dev. Min Max ## -------------------------------------------- ## y 10,000 11.7 37.7 -168.8 164.3 ## x_2 10,000 0.5 0.5 0 1 ## x_3 10,000 0.0 1.0 -4.7 3.9 ## x_23 10,000 0.004 0.7 -4.7 3.9 ## x_5 10,000 -0.0 1.0 -4.4 3.8 ## -------------------------------------------- #The table will be saved in the working directory #with whatever name you write in the out option. #You can open this file with any word processor Now we are going to sample this population and run a SRF. library(stargazer) n &lt;- 500 #sample size ind &lt;- sample(nrow(pop), n, replace = FALSE) sample &lt;- pop[ind, ] str(sample) ## &#39;data.frame&#39;: 500 obs. of 5 variables: ## $ y : num 10.7 44.7 -47.1 -30.6 24 ... ## $ x_2 : num 0 1 0 0 1 0 1 1 1 0 ... ## $ x_3 : num -0.111 0.705 -1.62 -1.153 0.358 ... ## $ x_23: num 0 0.705 0 0 0.358 ... ## $ x_5 : num 0.627 1.528 -0.889 -0.722 0.281 ... model &lt;- lm(y ~ ., data = sample) stargazer(model, type = &quot;text&quot;, title = &quot;G O O D - M O D E L&quot;, dep.var.labels = &quot;Y&quot;, digits = 3) ## ## G O O D - M O D E L ## ================================================ ## Dependent variable: ## ---------------------------- ## Y ## ------------------------------------------------ ## x_2 -0.718*** ## (0.087) ## ## x_3 34.025*** ## (0.068) ## ## x_23 -0.162* ## (0.085) ## ## x_5 5.357*** ## (0.058) ## ## Constant 12.075*** ## (0.060) ## ## ------------------------------------------------ ## Observations 500 ## R2 0.999 ## Adjusted R2 0.999 ## Residual Std. Error 0.974 (df = 495) ## F Statistic 196,907.500*** (df = 4; 495) ## ================================================ ## Note: *p&lt;0.1; **p&lt;0.05; ***p&lt;0.01 As you can see the coefficients are very close to our “true” coefficients specified in DGM. Now we can test what happens if we omit \\(x_5\\) in our SRF and estimate it. library(stargazer) n &lt;- 500 #sample size sample &lt;- pop[sample(nrow(pop), n, replace = FALSE), ] str(sample) ## &#39;data.frame&#39;: 500 obs. of 5 variables: ## $ y : num -21.42 35.02 -2.79 -12.15 -10.37 ... ## $ x_2 : num 0 1 1 0 0 0 0 1 0 1 ... ## $ x_3 : num -0.828 0.65 -0.387 -0.907 -0.423 ... ## $ x_23: num 0 0.65 -0.387 0 0 ... ## $ x_5 : num -1.035 0.194 -0.298 1.311 -1.467 ... model_bad &lt;- lm(y ~ x_2 + x_3 + x_23, data = sample) stargazer(model_bad, type = &quot;text&quot;, title = &quot;B A D - M O D E L&quot;, dep.var.labels = &quot;Y&quot;, digits = 3) ## ## B A D - M O D E L ## =============================================== ## Dependent variable: ## --------------------------- ## Y ## ----------------------------------------------- ## x_2 -0.717* ## (0.379) ## ## x_3 37.534*** ## (0.275) ## ## x_23 -0.581 ## (0.406) ## ## Constant 11.861*** ## (0.266) ## ## ----------------------------------------------- ## Observations 500 ## R2 0.986 ## Adjusted R2 0.986 ## Residual Std. Error 4.231 (df = 496) ## F Statistic 11,326.660*** (df = 3; 496) ## =============================================== ## Note: *p&lt;0.1; **p&lt;0.05; ***p&lt;0.01 Now it seems that none of the coefficients are as good as before, except for the intercept. This is a so-called omitted variable bias (OVB) problem, also known as a model underfitting or specification error. Would be the case that that this is a problem for only one sample? We can simulate the results many times and see whether on average \\(\\hat{\\beta_3}\\) is biased or not. n.sims &lt;- 500 n &lt;- 500 #sample size beta_3 &lt;- c(NA, n.sims) for (i in 1:n.sims){ sample &lt;- pop[sample(nrow(pop), n, replace = FALSE), ] model_bad &lt;- lm(y ~ x_2 + x_3 + x_23, data = sample) beta_3[i] &lt;- model_bad$coefficients[&quot;x_3&quot;] } summary(beta_3) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 36.56 37.33 37.49 37.50 37.68 38.19 As we can see the OVB problem is not a problem in one sample. We withdrew a sample and estimated the same underfitting model 500 times with a simulation. Therefore we collected 500 \\(\\hat{\\beta_3}\\). The average is 37.47. If we do the same simulation with a model that is correctly specified, you can see the results: the average of 500 \\(\\hat{\\beta_3}\\) is 34, which is the “correct”true” coefficent in our DGM. n.sims &lt;- 500 n &lt;- 500 #sample size beta_3 &lt;- c(NA, n.sims) for (i in 1:n.sims){ sample &lt;- pop[sample(nrow(pop), n, replace = FALSE), ] model_good &lt;- lm(y ~ x_2 + x_3 + x_23 + x_5, data = sample) beta_3[i] &lt;- model_good$coefficients[&quot;x_3&quot;] } summary(beta_3) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 33.81 33.96 34.02 34.01 34.06 34.23 8.5 Bootstrapping Bootstrapping is the process of resampling with replacement (all values in the sample have an equal probability of being selected, including multiple times, so a value could have duplicates). Resample, calculate a statistic (e.g. the mean), repeat this hundreds or thousands of times and you are able to estimate a precise/accurate uncertainty of the mean (confidence interval) of the data’s distribution. There are less assumptions about the underlying distribution using bootstrap compared to calculating the standard error directly. Generally bootstrapping follows the same basic steps: Resample a given data set a specified number of times, Calculate a specific statistic from each sample, Find the standard deviation of the distribution of that statistic. In the following bootstrapping example we would like to obtain a standard error for the estimate of the mean. We will be using the lapply(), sapply() functions in combination with the sample function. (see https://stats.idre.ucla.edu/r/library/r-library-introduction-to-bootstrapping/)(UCLA_2021?) #creating the data set by taking 100 observations #from a normal distribution with mean 5 and stdev 3 set.seed(123) data &lt;- rnorm(100, 5, 3) #rounding each observation to nearest integer data[1:10] ## [1] 3.318573 4.309468 9.676125 5.211525 5.387863 10.145195 6.382749 ## [8] 1.204816 2.939441 3.663014 #obtaining 20 bootstrap samples and storing in a list resamples &lt;- lapply(1:20, function(i) sample(data, replace = T)) #display the first of the bootstrap samples resamples[1] ## [[1]] ## [1] 8.76144476 3.11628177 4.02220524 10.36073941 6.30554447 9.10580685 ## [7] 2.93597415 3.60003394 3.58162578 6.34462934 5.71619521 7.06592076 ## [13] 4.91435973 4.34607526 7.33989536 4.37624817 5.37156273 6.93312965 ## [19] 8.67224539 4.32268704 1.20481630 1.63067425 4.33854031 5.91058592 ## [25] 4.14568098 1.63067425 11.15025406 -1.92750663 11.50686790 4.11478555 ## [31] 7.06592076 8.62388599 5.33204815 10.36073941 8.29051704 7.68537698 ## [37] 3.85858700 3.85858700 3.66301409 4.02220524 -1.92750663 6.15584120 ## [43] 2.93944144 6.38274862 6.38274862 6.75384125 6.13891845 2.87239771 ## [49] 2.81332631 4.00037785 9.10580685 1.92198666 -0.06007993 7.68537698 ## [55] 0.35374159 1.58558919 3.66301409 4.87138863 9.10580685 4.14568098 ## [61] 8.67224539 3.12488220 4.91435973 -0.06007993 6.38274862 3.12488220 ## [67] 8.29051704 8.44642286 4.11478555 6.93312965 2.81332631 0.35374159 ## [73] 8.01721557 1.92198666 5.33204815 10.14519496 7.98051157 3.31857306 ## [79] 8.44642286 6.75384125 5.01729256 1.58558919 -0.06007993 7.51336113 ## [85] 4.33854031 6.38274862 5.64782471 -0.06007993 2.91587906 6.93312965 ## [91] 10.14519496 3.11628177 6.27939266 5.71619521 6.49355143 1.94427385 ## [97] 6.66175296 0.35374159 3.58162578 7.46474324 Here is another way to do the same thing: set.seed(123) data &lt;- rnorm(100, 5, 3) resamples_2 &lt;- matrix(NA, nrow = 100, ncol = 20) for (i in 1:20) { resamples_2[,i] &lt;- sample(data, 100, replace = TRUE) } str(resamples_2) ## num [1:100, 1:20] 8.76 3.12 4.02 10.36 6.31 ... #display the first of the bootstrap samples resamples_2[, 1] ## [1] 8.76144476 3.11628177 4.02220524 10.36073941 6.30554447 9.10580685 ## [7] 2.93597415 3.60003394 3.58162578 6.34462934 5.71619521 7.06592076 ## [13] 4.91435973 4.34607526 7.33989536 4.37624817 5.37156273 6.93312965 ## [19] 8.67224539 4.32268704 1.20481630 1.63067425 4.33854031 5.91058592 ## [25] 4.14568098 1.63067425 11.15025406 -1.92750663 11.50686790 4.11478555 ## [31] 7.06592076 8.62388599 5.33204815 10.36073941 8.29051704 7.68537698 ## [37] 3.85858700 3.85858700 3.66301409 4.02220524 -1.92750663 6.15584120 ## [43] 2.93944144 6.38274862 6.38274862 6.75384125 6.13891845 2.87239771 ## [49] 2.81332631 4.00037785 9.10580685 1.92198666 -0.06007993 7.68537698 ## [55] 0.35374159 1.58558919 3.66301409 4.87138863 9.10580685 4.14568098 ## [61] 8.67224539 3.12488220 4.91435973 -0.06007993 6.38274862 3.12488220 ## [67] 8.29051704 8.44642286 4.11478555 6.93312965 2.81332631 0.35374159 ## [73] 8.01721557 1.92198666 5.33204815 10.14519496 7.98051157 3.31857306 ## [79] 8.44642286 6.75384125 5.01729256 1.58558919 -0.06007993 7.51336113 ## [85] 4.33854031 6.38274862 5.64782471 -0.06007993 2.91587906 6.93312965 ## [91] 10.14519496 3.11628177 6.27939266 5.71619521 6.49355143 1.94427385 ## [97] 6.66175296 0.35374159 3.58162578 7.46474324 Calculating the mean for each bootstrap sample: colMeans(resamples_2) ## [1] 5.095470 5.611315 5.283893 4.930731 4.804722 5.187125 4.946582 4.952693 ## [9] 5.470162 5.058354 4.790996 5.357154 5.479364 5.366046 5.454458 5.474732 ## [17] 5.566421 5.229395 5.111966 5.262666 #and the mean of all means mean(colMeans(resamples_2)) ## [1] 5.221712 Calculating the standard deviation of the distribution of means: sqrt(var(colMeans(resamples_2))) ## [1] 0.2523254 8.6 Monty Hall - Fun example The Monty Hall problem is a brain teaser, in the form of a probability puzzle, loosely based on the American television game show Let’s Make a Deal and named after its original host, Monty Hall. The problem was originally posed (and solved) in a letter by Steve Selvin to the American Statistician in 1975 (Selvin 1975a), (Selvin 1975b). It became famous as a question from a reader’s letter quoted in Marilyn vos Savant’s “Ask Marilyn” column in Parade magazine in 1990: Suppose you’re on a game show, and you’re given the choice of three doors: Behind one door is a car; behind the others, goats. You pick a door, say No. 1, and the host, who knows what’s behind the doors, opens another door, say No. 3, which has a goat. He then says to you, “Do you want to pick door No. 2?” Is it to your advantage to switch your choice? Vos Savant’s response was that the contestant should switch to the other door (vos Savant 1990a). Under the standard assumptions, contestants who switch have a 2/3 chance of winning the car, while contestants who stick to their initial choice have only a 1/3 chance. Many readers of vos Savant’s column refused to believe switching is beneficial despite her explanation. After the problem appeared in Parade, approximately 10,000 readers, including nearly 1,000 with PhDs, wrote to the magazine, most of them claiming vos Savant was wrong. Even when given explanations, simulations, and formal mathematical proofs, many people still do not accept that switching is the best strategy. Paul Erdős, one of the most prolific mathematicians in history, remained unconvinced until he was shown a computer simulation demonstrating the predicted result. The given probabilities depend on specific assumptions about how the host and contestant choose their doors. A key insight is that, under these standard conditions, there is more information about doors 2 and 3 that was not available at the beginning of the game, when door 1 was chosen by the player: the host’s deliberate action adds value to the door he did not choose to eliminate, but not to the one chosen by the contestant originally. Another insight is that switching doors is a different action than choosing between the two remaining doors at random, as the first action uses the previous information and the latter does not. Other possible behaviors than the one described can reveal different additional information, or none at all, and yield different probabilities. Here is the simple Bayes rule: \\(Pr(A|B) = Pr(B|A)Pr(A)/Pr(B)\\). Let’s play it: The player picks Door 1, Monty Hall opens Door 3. My question is this: \\(Pr(CAR = 1|Open = 3) &lt; Pr(CAR = 2|Open = 3)\\)? If this is true the player should always switch. Here is the Bayesian answer: \\(Pr(Car=1|Open=3) = Pr(Open=3|Car=1)Pr(Car=1)/Pr(Open=3)\\) = 1/2 x (1/3) / (1/2) = 1/3 Let’s see each number. Given that the player picks Door 1, if the car is behind Door 1, Monty should be indifferent between opening Doors 2 and 3. So the first term is 1/2. The second term is easy: Probability that the car is behind Door 1 is 1/3. The third term is also simple and usualy overlooked. This is not a conditional probability. If the car were behind Door 2, the probability that Monty opens Door 3 would be 1. And this explains why the second option is different, below: \\(Pr(Car=2|Open=3) = Pr(Open=3|Car=2)Pr(Car=2)/Pr(Open=3)\\) = 1 x (1/3) / (1/2) = 2/3 Image taken from http://media.graytvinc.com/images/690*388/mon+tyhall.jpg Simulation to prove it Step 1: Decide the number of plays n &lt;- 100000 Step 2: Define all possible door combinations 3 doors, the first one has the car. All possible outcomes for the game: outcomes &lt;- c(123,132,213,231,312,321) Step 3: Create empty containers where you store the outcomes from each game car &lt;- rep(0, n) goat1 &lt;- rep(0, n) goat2 &lt;- rep(0, n) choice &lt;- rep(0,n) monty &lt;- rep(0, n) winner &lt;- rep(0, n) Step 4: Loop for (i in 1:n){ doors &lt;- sample(outcomes,1) #The game&#39;s door combination car[i] &lt;- substring(doors, first = c(1,2,3), last = c(1,2,3))[1] #the right door goat1[i] &lt;- substring(doors, first = c(1,2,3), last = c(1,2,3))[2] #The first wrong door goat2[i] &lt;- substring(doors, first = c(1,2,3), last = c(1,2,3))[3] #The second wrong door #Person selects a random door choice[i] &lt;- sample(1:3,1) #Now Monty opens a door if (choice[i] == car[i]) {monty[i] = sample(c(goat1[i],goat2[i]),1)} else if (choice[i] == goat1[i]) {monty[i] = goat2[i]} else {monty[i] = goat1[i]} # 1 represents the stayer who remains by her initial choice # 2 represents the switcher who changes her initial choice if (choice[i] == car[i]){winner[i] = 1} else {winner[i] = 2} } Step 5: Chart hist(winner, breaks = 2, main = &quot;Who would win the most?&quot;, ylim = c(0,70000), labels = c(&quot;Stayer&quot;, &quot;Switcher&quot;), col = c(&quot;aliceblue&quot;, &quot;pink&quot;), cex.axis = 0.75, cex.lab = 0.75, cex.main = 0.85) The simulation is inspired by https://theressomethingaboutr.wordpress.com/2019/02/12/in-memory-of-monty-hall/ (Rajter_2019?) "],["parts.html", "Chapter 9 Parts", " Chapter 9 Parts You can add parts to organize one or more book chapters together. Parts can be inserted at the top of an .Rmd file, before the first-level chapter heading in that same file. Add a numbered part: # (PART) Act one {-} (followed by # A chapter) Add an unnumbered part: # (PART\\*) Act one {-} (followed by # A chapter) Add an appendix as a special kind of un-numbered part: # (APPENDIX) Other stuff {-} (followed by # A chapter). Chapters in an appendix are prepended with letters instead of numbers. "],["footnotes-and-citations.html", "Chapter 10 Footnotes and citations 10.1 Footnotes 10.2 Citations", " Chapter 10 Footnotes and citations 10.1 Footnotes Footnotes are put inside the square brackets after a caret ^[]. Like this one 1. 10.2 Citations Reference items in your bibliography file(s) using @key. For example, we are using the bookdown package (Xie 2022) (check out the last code chunk in index.Rmd to see how this citation key was added) in this sample book, which was built on top of R Markdown and knitr (Xie 2015) (this citation was added manually in an external file book.bib). Note that the .bib files need to be listed in the index.Rmd with the YAML bibliography key. The RStudio Visual Markdown Editor can also make it easier to insert citations: https://rstudio.github.io/visual-markdown-editing/#/citations References "],["blocks.html", "Chapter 11 Blocks 11.1 Equations 11.2 Theorems and proofs 11.3 Callout blocks", " Chapter 11 Blocks 11.1 Equations Here is an equation. \\[\\begin{equation} f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k} \\tag{11.1} \\end{equation}\\] You may refer to using \\@ref(eq:binom), like see Equation (11.1). 11.2 Theorems and proofs Labeled theorems can be referenced in text using \\@ref(thm:tri), for example, check out this smart theorem 11.1. Theorem 11.1 For a right triangle, if \\(c\\) denotes the length of the hypotenuse and \\(a\\) and \\(b\\) denote the lengths of the other two sides, we have \\[a^2 + b^2 = c^2\\] Read more here https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html. 11.3 Callout blocks The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html "],["sharing-your-book.html", "Chapter 12 Sharing your book 12.1 Publishing 12.2 404 pages 12.3 Metadata for sharing", " Chapter 12 Sharing your book 12.1 Publishing HTML books can be published online, see: https://bookdown.org/yihui/bookdown/publishing.html 12.2 404 pages By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you’d like to customize your 404 page instead of using the default, you may add either a _404.Rmd or _404.md file to your project root and use code and/or Markdown syntax. 12.3 Metadata for sharing Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the index.Rmd YAML. To setup, set the url for your book and the path to your cover-image file. Your book’s title and description are also used. This gitbook uses the same social sharing data across all chapters in your book- all links shared will look the same. Specify your book’s source repository on GitHub using the edit key under the configuration options in the _output.yml file, which allows users to suggest an edit by linking to a chapter’s source file. Read more about the features of this output format here: https://pkgs.rstudio.com/bookdown/reference/gitbook.html Or use: ?bookdown::gitbook "],["references.html", "References", " References "],["cross.html", "Chapter 13 Cross-references 13.1 Chapters and sub-chapters 13.2 Captioned figures and tables", " Chapter 13 Cross-references Cross-references make it easier for your readers to find and link to elements in your book. 13.1 Chapters and sub-chapters There are two steps to cross-reference any heading: Label the heading: # Hello world {#nice-label}. Leave the label off if you like the automated heading generated based on your heading title: for example, # Hello world = # Hello world {#hello-world}. To label an un-numbered heading, use: # Hello world {-#nice-label} or {# Hello world .unnumbered}. Next, reference the labeled heading anywhere in the text using \\@ref(nice-label); for example, please see Chapter 13. If you prefer text as the link instead of a numbered reference use: any text you want can go here. 13.2 Captioned figures and tables Figures and tables with captions can also be cross-referenced from elsewhere in your book using \\@ref(fig:chunk-label) and \\@ref(tab:chunk-label), respectively. See Figure 13.1. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 13.1: Here is a nice figure! Don’t miss Table 13.1. knitr::kable( head(pressure, 10), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 13.1: Here is a nice table! temperature pressure 0 0.0002 20 0.0012 40 0.0060 60 0.0300 80 0.0900 100 0.2700 120 0.7500 140 1.8500 160 4.2000 180 8.8000 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
